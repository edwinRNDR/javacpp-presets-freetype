// Targeted by JavaCPP version 1.5.2-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.freetype.global;

import org.bytedeco.freetype.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class freetype extends org.bytedeco.freetype.presets.freetype {
    static { Loader.load(); }

// Parsed from <ft2build.h>

/****************************************************************************
 *
 * ft2build.h
 *
 *   FreeType 2 build and setup macros.
 *
 * Copyright (C) 1996-2019 by
 * David Turner, Robert Wilhelm, and Werner Lemberg.
 *
 * This file is part of the FreeType project, and may only be used,
 * modified, and distributed under the terms of the FreeType project
 * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 * this file you indicate that you have read the license and
 * understand and accept it fully.
 *
 */


  /**************************************************************************
   *
   * This is the 'entry point' for FreeType header file inclusions.  It is
   * the only header file which should be included directly; all other
   * FreeType header files should be accessed with macro names (after
   * including {@code ft2build.h}).
   *
   * A typical example is
   *
   * <pre>{@code
   *   #include <ft2build.h>
   *   #include FT_FREETYPE_H
   * }</pre>
   *
   */


// #ifndef FT2BUILD_H_
// #define FT2BUILD_H_

// #include <freetype/config/ftheader.h>

// #endif /* FT2BUILD_H_ */


/* END */


// Parsed from <freetype/fttypes.h>

/****************************************************************************
 *
 * fttypes.h
 *
 *   FreeType simple types definitions (specification only).
 *
 * Copyright (C) 1996-2019 by
 * David Turner, Robert Wilhelm, and Werner Lemberg.
 *
 * This file is part of the FreeType project, and may only be used,
 * modified, and distributed under the terms of the FreeType project
 * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 * this file you indicate that you have read the license and
 * understand and accept it fully.
 *
 */


// #ifndef FTTYPES_H_
// #define FTTYPES_H_


// #include <ft2build.h>
// #include FT_CONFIG_CONFIG_H
// #include FT_SYSTEM_H
// #include FT_IMAGE_H

// #include <stddef.h>


  /**************************************************************************
   *
   * \type:
   *   FT_FWord
   *
   * \description:
   *   A signed 16-bit integer used to store a distance in original font
   *   units.
   */   /* distance in FUnits */


  /**************************************************************************
   *
   * \type:
   *   FT_UFWord
   *
   * \description:
   *   An unsigned 16-bit integer used to store a distance in original font
   *   units.
   */  /* unsigned distance */


  /**************************************************************************
   *
   * \type:
   *   FT_Char
   *
   * \description:
   *   A simple typedef for the _signed_ char type.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_Byte
   *
   * \description:
   *   A simple typedef for the _unsigned_ char type.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_Bytes
   *
   * \description:
   *   A typedef for constant memory areas.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_Tag
   *
   * \description:
   *   A typedef for 32-bit tags (as used in the SFNT format).
   */


  /**************************************************************************
   *
   * \type:
   *   FT_String
   *
   * \description:
   *   A simple typedef for the char type, usually used for strings.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_Short
   *
   * \description:
   *   A typedef for signed short.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_UShort
   *
   * \description:
   *   A typedef for unsigned short.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_Int
   *
   * \description:
   *   A typedef for the int type.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_UInt
   *
   * \description:
   *   A typedef for the unsigned int type.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_Long
   *
   * \description:
   *   A typedef for signed long.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_ULong
   *
   * \description:
   *   A typedef for unsigned long.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_F2Dot14
   *
   * \description:
   *   A signed 2.14 fixed-point type used for unit vectors.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_F26Dot6
   *
   * \description:
   *   A signed 26.6 fixed-point type used for vectorial pixel coordinates.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_Fixed
   *
   * \description:
   *   This type is used to store 16.16 fixed-point values, like scaling
   *   values or matrix coefficients.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_Error
   *
   * \description:
   *   The FreeType error code type.  A value of~0 is always interpreted as a
   *   successful operation.
   */
// Targeting ../FT_Pointer.java




  /**************************************************************************
   *
   * \type:
   *   FT_Offset
   *
   * \description:
   *   This is equivalent to the ANSI~C {@code size_t} type, i.e., the largest
   *   _unsigned_ integer type used to express a file size or position, or a
   *   memory block size.
   */


  /**************************************************************************
   *
   * \type:
   *   FT_PtrDist
   *
   * \description:
   *   This is equivalent to the ANSI~C {@code ptrdiff_t} type, i.e., the largest
   *   _signed_ integer type used to express the distance between two
   *   pointers.
   */
// Targeting ../FT_UnitVector.java


// Targeting ../FT_Matrix.java


// Targeting ../FT_Data.java


// Targeting ../FT_Generic_Finalizer.java


// Targeting ../FT_Generic.java




  /**************************************************************************
   *
   * \macro:
   *   FT_MAKE_TAG
   *
   * \description:
   *   This macro converts four-letter tags that are used to label TrueType
   *   tables into an unsigned long, to be used within FreeType.
   *
   * \note:
   *   The produced values **must** be 32-bit integers.  Don't redefine this
   *   macro.
   */
// #define FT_MAKE_TAG( _x1, _x2, _x3, _x4 )
//           (FT_Tag)
//           ( ( (FT_ULong)_x1 << 24 ) |
//             ( (FT_ULong)_x2 << 16 ) |
//             ( (FT_ULong)_x3 <<  8 ) |
//               (FT_ULong)_x4         )
// Targeting ../FT_ListNode.java


// Targeting ../FT_ListRec_.java


// Targeting ../FT_ListNodeRec.java


// Targeting ../FT_ListRec.java



  /* */


// #define FT_IS_EMPTY( list )  ( (list).head == 0 )
// #define FT_BOOL( x )  ( (FT_Bool)( (x) != 0 ) )

  /* concatenate C tokens */
// #define FT_ERR_XCAT( x, y )  x ## y
// #define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )

  /* see `ftmoderr.h` for descriptions of the following macros */

// #define FT_ERR( e )  FT_ERR_CAT( FT_ERR_PREFIX, e )

// #define FT_ERROR_BASE( x )    ( (x) & 0xFF )
// #define FT_ERROR_MODULE( x )  ( (x) & 0xFF00 )

// #define FT_ERR_EQ( x, e )
//           ( FT_ERROR_BASE( x ) == FT_ERROR_BASE( FT_ERR( e ) ) )
// #define FT_ERR_NEQ( x, e )
//           ( FT_ERROR_BASE( x ) != FT_ERROR_BASE( FT_ERR( e ) ) )

// #endif /* FTTYPES_H_ */


/* END */




// Parsed from <freetype/ftsystem.h>

/****************************************************************************
 *
 * ftsystem.h
 *
 *   FreeType low-level system interface definition (specification).
 *
 * Copyright (C) 1996-2019 by
 * David Turner, Robert Wilhelm, and Werner Lemberg.
 *
 * This file is part of the FreeType project, and may only be used,
 * modified, and distributed under the terms of the FreeType project
 * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 * this file you indicate that you have read the license and
 * understand and accept it fully.
 *
 */


// #ifndef FTSYSTEM_H_
// #define FTSYSTEM_H_


// #include <ft2build.h>
// Targeting ../FT_Alloc_Func.java


// Targeting ../FT_Free_Func.java


// Targeting ../FT_Realloc_Func.java


// Targeting ../FT_MemoryRec_.java


// Targeting ../FT_Stream.java


// Targeting ../FT_StreamDesc.java


// Targeting ../FT_Stream_IoFunc.java


// Targeting ../FT_Stream_CloseFunc.java


// Targeting ../FT_StreamRec.java



  /* */

// #endif /* FTSYSTEM_H_ */


/* END */




// Parsed from <freetype/ftimage.h>

/****************************************************************************
 *
 * ftimage.h
 *
 *   FreeType glyph image formats and default raster interface
 *   (specification).
 *
 * Copyright (C) 1996-2019 by
 * David Turner, Robert Wilhelm, and Werner Lemberg.
 *
 * This file is part of the FreeType project, and may only be used,
 * modified, and distributed under the terms of the FreeType project
 * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 * this file you indicate that you have read the license and
 * understand and accept it fully.
 *
 */

  /**************************************************************************
   *
   * Note: A 'raster' is simply a scan-line converter, used to render
   *       FT_Outlines into FT_Bitmaps.
   *
   */


// #ifndef FTIMAGE_H_
// #define FTIMAGE_H_


  /* STANDALONE_ is from ftgrays.c */
// #ifndef STANDALONE_
// #include <ft2build.h>
// #endif
// Targeting ../FT_Vector.java


// Targeting ../FT_BBox.java




  /**************************************************************************
   *
   * \enum:
   *   FT_Pixel_Mode
   *
   * \description:
   *   An enumeration type used to describe the format of pixels in a given
   *   bitmap.  Note that additional formats may be added in the future.
   *
   * \values:
   *   FT_PIXEL_MODE_NONE ::
   *     Value~0 is reserved.
   *
   *   FT_PIXEL_MODE_MONO ::
   *     A monochrome bitmap, using 1~bit per pixel.  Note that pixels are
   *     stored in most-significant order (MSB), which means that the
   *     left-most pixel in a byte has value 128.
   *
   *   FT_PIXEL_MODE_GRAY ::
   *     An 8-bit bitmap, generally used to represent anti-aliased glyph
   *     images.  Each pixel is stored in one byte.  Note that the number of
   *     'gray' levels is stored in the {@code num_grays} field of the \FT_Bitmap
   *     structure (it generally is 256).
   *
   *   FT_PIXEL_MODE_GRAY2 ::
   *     A 2-bit per pixel bitmap, used to represent embedded anti-aliased
   *     bitmaps in font files according to the OpenType specification.  We
   *     haven't found a single font using this format, however.
   *
   *   FT_PIXEL_MODE_GRAY4 ::
   *     A 4-bit per pixel bitmap, representing embedded anti-aliased bitmaps
   *     in font files according to the OpenType specification.  We haven't
   *     found a single font using this format, however.
   *
   *   FT_PIXEL_MODE_LCD ::
   *     An 8-bit bitmap, representing RGB or BGR decimated glyph images used
   *     for display on LCD displays; the bitmap is three times wider than
   *     the original glyph image.  See also \FT_RENDER_MODE_LCD.
   *
   *   FT_PIXEL_MODE_LCD_V ::
   *     An 8-bit bitmap, representing RGB or BGR decimated glyph images used
   *     for display on rotated LCD displays; the bitmap is three times
   *     taller than the original glyph image.  See also
   *     \FT_RENDER_MODE_LCD_V.
   *
   *   FT_PIXEL_MODE_BGRA ::
   *     [Since 2.5] An image with four 8-bit channels per pixel,
   *     representing a color image (such as emoticons) with alpha channel.
   *     For each pixel, the format is BGRA, which means, the blue channel
   *     comes first in memory.  The color channels are pre-multiplied and in
   *     the sRGB colorspace.  For example, full red at half-translucent
   *     opacity will be represented as '00,00,80,80', not '00,00,FF,80'.
   *     See also \FT_LOAD_COLOR.
   */
  /** enum FT_Pixel_Mode_ */
  public static final int
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO = 1,
    FT_PIXEL_MODE_GRAY = 2,
    FT_PIXEL_MODE_GRAY2 = 3,
    FT_PIXEL_MODE_GRAY4 = 4,
    FT_PIXEL_MODE_LCD = 5,
    FT_PIXEL_MODE_LCD_V = 6,
    FT_PIXEL_MODE_BGRA = 7,

    FT_PIXEL_MODE_MAX = 8;      /* do not remove */


  /* these constants are deprecated; use the corresponding `FT_Pixel_Mode` */
  /* values instead.                                                       */
public static final int ft_pixel_mode_none =   FT_PIXEL_MODE_NONE;
public static final int ft_pixel_mode_mono =   FT_PIXEL_MODE_MONO;
public static final int ft_pixel_mode_grays =  FT_PIXEL_MODE_GRAY;
public static final int ft_pixel_mode_pal2 =   FT_PIXEL_MODE_GRAY2;
public static final int ft_pixel_mode_pal4 =   FT_PIXEL_MODE_GRAY4;
// Targeting ../FT_Bitmap.java


// Targeting ../FT_Outline.java



  /* */

  /* Following limits must be consistent with */
  /* FT_Outline.{n_contours,n_points}         */
// #define FT_OUTLINE_CONTOURS_MAX  SHRT_MAX
// #define FT_OUTLINE_POINTS_MAX    SHRT_MAX


  /**************************************************************************
   *
   * \enum:
   *   FT_OUTLINE_XXX
   *
   * \description:
   *   A list of bit-field constants used for the flags in an outline's
   *   {@code flags} field.
   *
   * \values:
   *   FT_OUTLINE_NONE ::
   *     Value~0 is reserved.
   *
   *   FT_OUTLINE_OWNER ::
   *     If set, this flag indicates that the outline's field arrays (i.e.,
   *     {@code points}, {@code flags}, and {@code contours}) are 'owned' by the outline
   *     object, and should thus be freed when it is destroyed.
   *
   *   FT_OUTLINE_EVEN_ODD_FILL ::
   *     By default, outlines are filled using the non-zero winding rule.  If
   *     set to 1, the outline will be filled using the even-odd fill rule
   *     (only works with the smooth rasterizer).
   *
   *   FT_OUTLINE_REVERSE_FILL ::
   *     By default, outside contours of an outline are oriented in
   *     clock-wise direction, as defined in the TrueType specification.
   *     This flag is set if the outline uses the opposite direction
   *     (typically for Type~1 fonts).  This flag is ignored by the scan
   *     converter.
   *
   *   FT_OUTLINE_IGNORE_DROPOUTS ::
   *     By default, the scan converter will try to detect drop-outs in an
   *     outline and correct the glyph bitmap to ensure consistent shape
   *     continuity.  If set, this flag hints the scan-line converter to
   *     ignore such cases.  See below for more information.
   *
   *   FT_OUTLINE_SMART_DROPOUTS ::
   *     Select smart dropout control.  If unset, use simple dropout control.
   *     Ignored if \FT_OUTLINE_IGNORE_DROPOUTS is set.  See below for more
   *     information.
   *
   *   FT_OUTLINE_INCLUDE_STUBS ::
   *     If set, turn pixels on for 'stubs', otherwise exclude them.  Ignored
   *     if \FT_OUTLINE_IGNORE_DROPOUTS is set.  See below for more
   *     information.
   *
   *   FT_OUTLINE_HIGH_PRECISION ::
   *     This flag indicates that the scan-line converter should try to
   *     convert this outline to bitmaps with the highest possible quality.
   *     It is typically set for small character sizes.  Note that this is
   *     only a hint that might be completely ignored by a given
   *     scan-converter.
   *
   *   FT_OUTLINE_SINGLE_PASS ::
   *     This flag is set to force a given scan-converter to only use a
   *     single pass over the outline to render a bitmap glyph image.
   *     Normally, it is set for very large character sizes.  It is only a
   *     hint that might be completely ignored by a given scan-converter.
   *
   * \note:
   *   The flags \FT_OUTLINE_IGNORE_DROPOUTS, \FT_OUTLINE_SMART_DROPOUTS, and
   *   \FT_OUTLINE_INCLUDE_STUBS are ignored by the smooth rasterizer.
   *
   *   There exists a second mechanism to pass the drop-out mode to the B/W
   *   rasterizer; see the {@code tags} field in \FT_Outline.
   *
   *   Please refer to the description of the 'SCANTYPE' instruction in the
   *   OpenType specification (in file {@code ttinst1.doc}) how simple drop-outs,
   *   smart drop-outs, and stubs are defined.
   */
public static final int FT_OUTLINE_NONE =             0x0;
public static final int FT_OUTLINE_OWNER =            0x1;
public static final int FT_OUTLINE_EVEN_ODD_FILL =    0x2;
public static final int FT_OUTLINE_REVERSE_FILL =     0x4;
public static final int FT_OUTLINE_IGNORE_DROPOUTS =  0x8;
public static final int FT_OUTLINE_SMART_DROPOUTS =   0x10;
public static final int FT_OUTLINE_INCLUDE_STUBS =    0x20;

public static final int FT_OUTLINE_HIGH_PRECISION =   0x100;
public static final int FT_OUTLINE_SINGLE_PASS =      0x200;


  /* these constants are deprecated; use the corresponding */
  /* `FT_OUTLINE_XXX` values instead                       */
public static final int ft_outline_none =             FT_OUTLINE_NONE;
public static final int ft_outline_owner =            FT_OUTLINE_OWNER;
public static final int ft_outline_even_odd_fill =    FT_OUTLINE_EVEN_ODD_FILL;
public static final int ft_outline_reverse_fill =     FT_OUTLINE_REVERSE_FILL;
public static final int ft_outline_ignore_dropouts =  FT_OUTLINE_IGNORE_DROPOUTS;
public static final int ft_outline_high_precision =   FT_OUTLINE_HIGH_PRECISION;
public static final int ft_outline_single_pass =      FT_OUTLINE_SINGLE_PASS;

  /* */

// #define FT_CURVE_TAG( flag )  ( flag & 0x03 )

  /* see the `tags` field in `FT_Outline` for a description of the values */
public static final int FT_CURVE_TAG_ON =            0x01;
public static final int FT_CURVE_TAG_CONIC =         0x00;
public static final int FT_CURVE_TAG_CUBIC =         0x02;

public static final int FT_CURVE_TAG_HAS_SCANMODE =  0x04;

public static final int FT_CURVE_TAG_TOUCH_X =       0x08;  /* reserved for TrueType hinter */
public static final int FT_CURVE_TAG_TOUCH_Y =       0x10;  /* reserved for TrueType hinter */

public static final int FT_CURVE_TAG_TOUCH_BOTH =    ( FT_CURVE_TAG_TOUCH_X | 
                                     FT_CURVE_TAG_TOUCH_Y );
  /* values 0x20, 0x40, and 0x80 are reserved */


  /* these constants are deprecated; use the corresponding */
  /* `FT_CURVE_TAG_XXX` values instead                     */
public static final int FT_Curve_Tag_On =       FT_CURVE_TAG_ON;
public static final int FT_Curve_Tag_Conic =    FT_CURVE_TAG_CONIC;
public static final int FT_Curve_Tag_Cubic =    FT_CURVE_TAG_CUBIC;
public static final int FT_Curve_Tag_Touch_X =  FT_CURVE_TAG_TOUCH_X;
public static final int FT_Curve_Tag_Touch_Y =  FT_CURVE_TAG_TOUCH_Y;
// Targeting ../FT_Outline_MoveToFunc.java



// #define FT_Outline_MoveTo_Func  FT_Outline_MoveToFunc
// Targeting ../FT_Outline_LineToFunc.java



// #define FT_Outline_LineTo_Func  FT_Outline_LineToFunc
// Targeting ../FT_Outline_ConicToFunc.java



// #define FT_Outline_ConicTo_Func  FT_Outline_ConicToFunc
// Targeting ../FT_Outline_CubicToFunc.java



// #define FT_Outline_CubicTo_Func  FT_Outline_CubicToFunc
// Targeting ../FT_Outline_Funcs.java




  /**************************************************************************
   *
   * \section:
   *   basic_types
   *
   */


  /**************************************************************************
   *
   * \macro:
   *   FT_IMAGE_TAG
   *
   * \description:
   *   This macro converts four-letter tags to an unsigned long type.
   *
   * \note:
   *   Since many 16-bit compilers don't like 32-bit enumerations, you should
   *   redefine this macro in case of problems to something like this:
   *
   *   <pre>{@code
   *     #define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )  value
   *   }</pre>
   *
   *   to get a simple enumeration without assigning special numbers.
   */
// #ifndef FT_IMAGE_TAG
// #define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )
//           value = ( ( (unsigned long)_x1 << 24 ) |
//                     ( (unsigned long)_x2 << 16 ) |
//                     ( (unsigned long)_x3 << 8  ) |
//                       (unsigned long)_x4         )
// #endif /* FT_IMAGE_TAG */


  /**************************************************************************
   *
   * \enum:
   *   FT_Glyph_Format
   *
   * \description:
   *   An enumeration type used to describe the format of a given glyph
   *   image.  Note that this version of FreeType only supports two image
   *   formats, even though future font drivers will be able to register
   *   their own format.
   *
   * \values:
   *   FT_GLYPH_FORMAT_NONE ::
   *     The value~0 is reserved.
   *
   *   FT_GLYPH_FORMAT_COMPOSITE ::
   *     The glyph image is a composite of several other images.  This format
   *     is _only_ used with \FT_LOAD_NO_RECURSE, and is used to report
   *     compound glyphs (like accented characters).
   *
   *   FT_GLYPH_FORMAT_BITMAP ::
   *     The glyph image is a bitmap, and can be described as an \FT_Bitmap.
   *     You generally need to access the {@code bitmap} field of the
   *     \FT_GlyphSlotRec structure to read it.
   *
   *   FT_GLYPH_FORMAT_OUTLINE ::
   *     The glyph image is a vectorial outline made of line segments and
   *     Bezier arcs; it can be described as an \FT_Outline; you generally
   *     want to access the {@code outline} field of the \FT_GlyphSlotRec structure
   *     to read it.
   *
   *   FT_GLYPH_FORMAT_PLOTTER ::
   *     The glyph image is a vectorial path with no inside and outside
   *     contours.  Some Type~1 fonts, like those in the Hershey family,
   *     contain glyphs in this format.  These are described as \FT_Outline,
   *     but FreeType isn't currently capable of rendering them correctly.
   */
  /** enum FT_Glyph_Format_ */
  ;


  /* these constants are deprecated; use the corresponding */
  /* `FT_Glyph_Format` values instead.                     */
// #define ft_glyph_format_none       FT_GLYPH_FORMAT_NONE
// #define ft_glyph_format_composite  FT_GLYPH_FORMAT_COMPOSITE
// #define ft_glyph_format_bitmap     FT_GLYPH_FORMAT_BITMAP
// #define ft_glyph_format_outline    FT_GLYPH_FORMAT_OUTLINE
// #define ft_glyph_format_plotter    FT_GLYPH_FORMAT_PLOTTER
// Targeting ../FT_Raster.java


// Targeting ../FT_Span.java


// Targeting ../FT_SpanFunc.java



// #define FT_Raster_Span_Func  FT_SpanFunc
// Targeting ../FT_Raster_BitTest_Func.java


// Targeting ../FT_Raster_BitSet_Func.java




  /**************************************************************************
   *
   * \enum:
   *   FT_RASTER_FLAG_XXX
   *
   * \description:
   *   A list of bit flag constants as used in the {@code flags} field of a
   *   \FT_Raster_Params structure.
   *
   * \values:
   *   FT_RASTER_FLAG_DEFAULT ::
   *     This value is 0.
   *
   *   FT_RASTER_FLAG_AA ::
   *     This flag is set to indicate that an anti-aliased glyph image should
   *     be generated.  Otherwise, it will be monochrome (1-bit).
   *
   *   FT_RASTER_FLAG_DIRECT ::
   *     This flag is set to indicate direct rendering.  In this mode, client
   *     applications must provide their own span callback.  This lets them
   *     directly draw or compose over an existing bitmap.  If this bit is
   *     _not_ set, the target pixmap's buffer _must_ be zeroed before
   *     rendering and the output will be clipped to its size.
   *
   *     Direct rendering is only possible with anti-aliased glyphs.
   *
   *   FT_RASTER_FLAG_CLIP ::
   *     This flag is only used in direct rendering mode.  If set, the output
   *     will be clipped to a box specified in the {@code clip_box} field of the
   *     \FT_Raster_Params structure.  Otherwise, the {@code clip_box} is
   *     effectively set to the bounding box and all spans are generated.
   */
public static final int FT_RASTER_FLAG_DEFAULT =  0x0;
public static final int FT_RASTER_FLAG_AA =       0x1;
public static final int FT_RASTER_FLAG_DIRECT =   0x2;
public static final int FT_RASTER_FLAG_CLIP =     0x4;

  /* these constants are deprecated; use the corresponding */
  /* `FT_RASTER_FLAG_XXX` values instead                   */
public static final int ft_raster_flag_default =  FT_RASTER_FLAG_DEFAULT;
public static final int ft_raster_flag_aa =       FT_RASTER_FLAG_AA;
public static final int ft_raster_flag_direct =   FT_RASTER_FLAG_DIRECT;
public static final int ft_raster_flag_clip =     FT_RASTER_FLAG_CLIP;
// Targeting ../FT_Raster_Params.java


// Targeting ../FT_Raster_NewFunc.java



// #define FT_Raster_New_Func  FT_Raster_NewFunc
// Targeting ../FT_Raster_DoneFunc.java



// #define FT_Raster_Done_Func  FT_Raster_DoneFunc
// Targeting ../FT_Raster_ResetFunc.java



// #define FT_Raster_Reset_Func  FT_Raster_ResetFunc
// Targeting ../FT_Raster_SetModeFunc.java



// #define FT_Raster_Set_Mode_Func  FT_Raster_SetModeFunc
// Targeting ../FT_Raster_RenderFunc.java



// #define FT_Raster_Render_Func  FT_Raster_RenderFunc
// Targeting ../FT_Raster_Funcs.java



  /* */

// #endif /* FTIMAGE_H_ */


/* END */


/* Local Variables: */
/* coding: utf-8    */
/* End:             */




// Parsed from <freetype/freetype.h>

/****************************************************************************
 *
 * freetype.h
 *
 *   FreeType high-level API and common types (specification only).
 *
 * Copyright (C) 1996-2019 by
 * David Turner, Robert Wilhelm, and Werner Lemberg.
 *
 * This file is part of the FreeType project, and may only be used,
 * modified, and distributed under the terms of the FreeType project
 * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 * this file you indicate that you have read the license and
 * understand and accept it fully.
 *
 */


// #ifndef FREETYPE_H_
// #define FREETYPE_H_


// #ifndef FT_FREETYPE_H
// #error "`ft2build.h' hasn't been included yet!"
// #error "Please always use macros to include FreeType header files."
// #error "Example:"
// #error "  #include <ft2build.h>"
// #error "  #include FT_FREETYPE_H"
// #endif


// #include <ft2build.h>
// #include FT_CONFIG_CONFIG_H
// #include FT_TYPES_H
// #include FT_ERRORS_H
// Targeting ../FT_Glyph_Metrics.java


// Targeting ../FT_Bitmap_Size.java


// Targeting ../FT_Library.java


// Targeting ../FT_Module.java


// Targeting ../FT_Driver.java


// Targeting ../FT_Renderer.java


// Targeting ../FT_Face.java


// Targeting ../FT_Size.java


// Targeting ../FT_GlyphSlot.java


// Targeting ../FT_CharMap.java




  /**************************************************************************
   *
   * \macro:
   *   FT_ENC_TAG
   *
   * \description:
   *   This macro converts four-letter tags into an unsigned long.  It is
   *   used to define 'encoding' identifiers (see \FT_Encoding).
   *
   * \note:
   *   Since many 16-bit compilers don't like 32-bit enumerations, you should
   *   redefine this macro in case of problems to something like this:
   *
   *   <pre>{@code
   *     #define FT_ENC_TAG( value, a, b, c, d )  value
   *   }</pre>
   *
   *   to get a simple enumeration without assigning special numbers.
   */

// #ifndef FT_ENC_TAG
// #define FT_ENC_TAG( value, a, b, c, d )
//           value = ( ( (FT_UInt32)(a) << 24 ) |
//                     ( (FT_UInt32)(b) << 16 ) |
//                     ( (FT_UInt32)(c) <<  8 ) |
//                       (FT_UInt32)(d)         )

// #endif /* FT_ENC_TAG */


  /**************************************************************************
   *
   * \enum:
   *   FT_Encoding
   *
   * \description:
   *   An enumeration to specify character sets supported by charmaps.  Used
   *   in the \FT_Select_Charmap API function.
   *
   * \note:
   *   Despite the name, this enumeration lists specific character
   *   repertories (i.e., charsets), and not text encoding methods (e.g.,
   *   UTF-8, UTF-16, etc.).
   *
   *   Other encodings might be defined in the future.
   *
   * \values:
   *   FT_ENCODING_NONE ::
   *     The encoding value~0 is reserved for all formats except BDF, PCF,
   *     and Windows FNT; see below for more information.
   *
   *   FT_ENCODING_UNICODE ::
   *     The Unicode character set.  This value covers all versions of the
   *     Unicode repertoire, including ASCII and Latin-1.  Most fonts include
   *     a Unicode charmap, but not all of them.
   *
   *     For example, if you want to access Unicode value U+1F028 (and the
   *     font contains it), use value 0x1F028 as the input value for
   *     \FT_Get_Char_Index.
   *
   *   FT_ENCODING_MS_SYMBOL ::
   *     Microsoft Symbol encoding, used to encode mathematical symbols and
   *     wingdings.  For more information, see
   *     'https://www.microsoft.com/typography/otspec/recom.htm#non-standard-symbol-fonts',
   *     'http://www.kostis.net/charsets/symbol.htm', and
   *     'http://www.kostis.net/charsets/wingding.htm'.
   *
   *     This encoding uses character codes from the PUA (Private Unicode
   *     Area) in the range U+F020-U+F0FF.
   *
   *   FT_ENCODING_SJIS ::
   *     Shift JIS encoding for Japanese.  More info at
   *     'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte
   *     encodings below.
   *
   *   FT_ENCODING_PRC ::
   *     Corresponds to encoding systems mainly for Simplified Chinese as
   *     used in People's Republic of China (PRC).  The encoding layout is
   *     based on GB~2312 and its supersets GBK and GB~18030.
   *
   *   FT_ENCODING_BIG5 ::
   *     Corresponds to an encoding system for Traditional Chinese as used in
   *     Taiwan and Hong Kong.
   *
   *   FT_ENCODING_WANSUNG ::
   *     Corresponds to the Korean encoding system known as Extended Wansung
   *     (MS Windows code page 949).  For more information see
   *     'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.
   *
   *   FT_ENCODING_JOHAB ::
   *     The Korean standard character set (KS~C 5601-1992), which
   *     corresponds to MS Windows code page 1361.  This character set
   *     includes all possible Hangul character combinations.
   *
   *   FT_ENCODING_ADOBE_LATIN_1 ::
   *     Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript
   *     font.  It is limited to 256 character codes.
   *
   *   FT_ENCODING_ADOBE_STANDARD ::
   *     Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF
   *     fonts.  It is limited to 256 character codes.
   *
   *   FT_ENCODING_ADOBE_EXPERT ::
   *     Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF
   *     fonts.  It is limited to 256 character codes.
   *
   *   FT_ENCODING_ADOBE_CUSTOM ::
   *     Corresponds to a custom encoding, as found in Type~1, CFF, and
   *     OpenType/CFF fonts.  It is limited to 256 character codes.
   *
   *   FT_ENCODING_APPLE_ROMAN ::
   *     Apple roman encoding.  Many TrueType and OpenType fonts contain a
   *     charmap for this 8-bit encoding, since older versions of Mac OS are
   *     able to use it.
   *
   *   FT_ENCODING_OLD_LATIN_2 ::
   *     This value is deprecated and was neither used nor reported by
   *     FreeType.  Don't use or test for it.
   *
   *   FT_ENCODING_MS_SJIS ::
   *     Same as FT_ENCODING_SJIS.  Deprecated.
   *
   *   FT_ENCODING_MS_GB2312 ::
   *     Same as FT_ENCODING_PRC.  Deprecated.
   *
   *   FT_ENCODING_MS_BIG5 ::
   *     Same as FT_ENCODING_BIG5.  Deprecated.
   *
   *   FT_ENCODING_MS_WANSUNG ::
   *     Same as FT_ENCODING_WANSUNG.  Deprecated.
   *
   *   FT_ENCODING_MS_JOHAB ::
   *     Same as FT_ENCODING_JOHAB.  Deprecated.
   *
   * \note:
   *   By default, FreeType enables a Unicode charmap and tags it with
   *   {@code FT_ENCODING_UNICODE} when it is either provided or can be generated
   *   from PostScript glyph name dictionaries in the font file.  All other
   *   encodings are considered legacy and tagged only if explicitly defined
   *   in the font file.  Otherwise, {@code FT_ENCODING_NONE} is used.
   *
   *   {@code FT_ENCODING_NONE} is set by the BDF and PCF drivers if the charmap is
   *   neither Unicode nor ISO-8859-1 (otherwise it is set to
   *   {@code FT_ENCODING_UNICODE}).  Use \FT_Get_BDF_Charset_ID to find out which
   *   encoding is really present.  If, for example, the {@code cs_registry} field
   *   is 'KOI8' and the {@code cs_encoding} field is 'R', the font is encoded in
   *   KOI8-R.
   *
   *   {@code FT_ENCODING_NONE} is always set (with a single exception) by the
   *   winfonts driver.  Use \FT_Get_WinFNT_Header and examine the {@code charset}
   *   field of the \FT_WinFNT_HeaderRec structure to find out which encoding
   *   is really present.  For example, \FT_WinFNT_ID_CP1251 (204) means
   *   Windows code page 1251 (for Russian).
   *
   *   {@code FT_ENCODING_NONE} is set if {@code platform_id} is \TT_PLATFORM_MACINTOSH
   *   and {@code encoding_id} is not {@code TT_MAC_ID_ROMAN} (otherwise it is set to
   *   {@code FT_ENCODING_APPLE_ROMAN}).
   *
   *   If {@code platform_id} is \TT_PLATFORM_MACINTOSH, use the function
   *   \FT_Get_CMap_Language_ID to query the Mac language ID that may be
   *   needed to be able to distinguish Apple encoding variants.  See
   *
   *     https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
   *
   *   to get an idea how to do that.  Basically, if the language ID is~0,
   *   don't use it, otherwise subtract 1 from the language ID.  Then examine
   *   {@code encoding_id}.  If, for example, {@code encoding_id} is {@code TT_MAC_ID_ROMAN}
   *   and the language ID (minus~1) is {@code TT_MAC_LANGID_GREEK}, it is the
   *   Greek encoding, not Roman.  {@code TT_MAC_ID_ARABIC} with
   *   {@code TT_MAC_LANGID_FARSI} means the Farsi variant the Arabic encoding.
   */
  /** enum FT_Encoding_ */
  ;


  /* these constants are deprecated; use the corresponding `FT_Encoding` */
  /* values instead                                                      */
// #define ft_encoding_none            FT_ENCODING_NONE
// #define ft_encoding_unicode         FT_ENCODING_UNICODE
// #define ft_encoding_symbol          FT_ENCODING_MS_SYMBOL
// #define ft_encoding_latin_1         FT_ENCODING_ADOBE_LATIN_1
// #define ft_encoding_latin_2         FT_ENCODING_OLD_LATIN_2
// #define ft_encoding_sjis            FT_ENCODING_SJIS
// #define ft_encoding_gb2312          FT_ENCODING_PRC
// #define ft_encoding_big5            FT_ENCODING_BIG5
// #define ft_encoding_wansung         FT_ENCODING_WANSUNG
// #define ft_encoding_johab           FT_ENCODING_JOHAB

// #define ft_encoding_adobe_standard  FT_ENCODING_ADOBE_STANDARD
// #define ft_encoding_adobe_expert    FT_ENCODING_ADOBE_EXPERT
// #define ft_encoding_adobe_custom    FT_ENCODING_ADOBE_CUSTOM
// #define ft_encoding_apple_roman     FT_ENCODING_APPLE_ROMAN
// Targeting ../FT_CharMapRec.java


// Targeting ../FT_Face_Internal.java


// Targeting ../FT_FaceRec.java




  /**************************************************************************
   *
   * \enum:
   *   FT_FACE_FLAG_XXX
   *
   * \description:
   *   A list of bit flags used in the {@code face_flags} field of the \FT_FaceRec
   *   structure.  They inform client applications of properties of the
   *   corresponding face.
   *
   * \values:
   *   FT_FACE_FLAG_SCALABLE ::
   *     The face contains outline glyphs.  Note that a face can contain
   *     bitmap strikes also, i.e., a face can have both this flag and
   *     \FT_FACE_FLAG_FIXED_SIZES set.
   *
   *   FT_FACE_FLAG_FIXED_SIZES ::
   *     The face contains bitmap strikes.  See also the {@code num_fixed_sizes}
   *     and {@code available_sizes} fields of \FT_FaceRec.
   *
   *   FT_FACE_FLAG_FIXED_WIDTH ::
   *     The face contains fixed-width characters (like Courier, Lucida,
   *     MonoType, etc.).
   *
   *   FT_FACE_FLAG_SFNT ::
   *     The face uses the SFNT storage scheme.  For now, this means TrueType
   *     and OpenType.
   *
   *   FT_FACE_FLAG_HORIZONTAL ::
   *     The face contains horizontal glyph metrics.  This should be set for
   *     all common formats.
   *
   *   FT_FACE_FLAG_VERTICAL ::
   *     The face contains vertical glyph metrics.  This is only available in
   *     some formats, not all of them.
   *
   *   FT_FACE_FLAG_KERNING ::
   *     The face contains kerning information.  If set, the kerning distance
   *     can be retrieved using the function \FT_Get_Kerning.  Otherwise the
   *     function always return the vector (0,0).  Note that FreeType doesn't
   *     handle kerning data from the SFNT 'GPOS' table (as present in many
   *     OpenType fonts).
   *
   *   FT_FACE_FLAG_FAST_GLYPHS ::
   *     THIS FLAG IS DEPRECATED.  DO NOT USE OR TEST IT.
   *
   *   FT_FACE_FLAG_MULTIPLE_MASTERS ::
   *     The face contains multiple masters and is capable of interpolating
   *     between them.  Supported formats are Adobe MM, TrueType GX, and
   *     OpenType variation fonts.
   *
   *     See section \multiple_masters for API details.
   *
   *   FT_FACE_FLAG_GLYPH_NAMES ::
   *     The face contains glyph names, which can be retrieved using
   *     \FT_Get_Glyph_Name.  Note that some TrueType fonts contain broken
   *     glyph name tables.  Use the function \FT_Has_PS_Glyph_Names when
   *     needed.
   *
   *   FT_FACE_FLAG_EXTERNAL_STREAM ::
   *     Used internally by FreeType to indicate that a face's stream was
   *     provided by the client application and should not be destroyed when
   *     \FT_Done_Face is called.  Don't read or test this flag.
   *
   *   FT_FACE_FLAG_HINTER ::
   *     The font driver has a hinting machine of its own.  For example, with
   *     TrueType fonts, it makes sense to use data from the SFNT 'gasp'
   *     table only if the native TrueType hinting engine (with the bytecode
   *     interpreter) is available and active.
   *
   *   FT_FACE_FLAG_CID_KEYED ::
   *     The face is CID-keyed.  In that case, the face is not accessed by
   *     glyph indices but by CID values.  For subsetted CID-keyed fonts this
   *     has the consequence that not all index values are a valid argument
   *     to \FT_Load_Glyph.  Only the CID values for which corresponding
   *     glyphs in the subsetted font exist make {@code FT_Load_Glyph} return
   *     successfully; in all other cases you get an
   *     {@code FT_Err_Invalid_Argument} error.
   *
   *     Note that CID-keyed fonts that are in an SFNT wrapper (this is, all
   *     OpenType/CFF fonts) don't have this flag set since the glyphs are
   *     accessed in the normal way (using contiguous indices); the
   *     'CID-ness' isn't visible to the application.
   *
   *   FT_FACE_FLAG_TRICKY ::
   *     The face is 'tricky', this is, it always needs the font format's
   *     native hinting engine to get a reasonable result.  A typical example
   *     is the old Chinese font {@code mingli.ttf} (but not {@code mingliu.ttc}) that
   *     uses TrueType bytecode instructions to move and scale all of its
   *     subglyphs.
   *
   *     It is not possible to auto-hint such fonts using
   *     \FT_LOAD_FORCE_AUTOHINT; it will also ignore \FT_LOAD_NO_HINTING.
   *     You have to set both \FT_LOAD_NO_HINTING and \FT_LOAD_NO_AUTOHINT to
   *     really disable hinting; however, you probably never want this except
   *     for demonstration purposes.
   *
   *     Currently, there are about a dozen TrueType fonts in the list of
   *     tricky fonts; they are hard-coded in file {@code ttobjs.c}.
   *
   *   FT_FACE_FLAG_COLOR ::
   *     [Since 2.5.1] The face has color glyph tables.  See \FT_LOAD_COLOR
   *     for more information.
   *
   *   FT_FACE_FLAG_VARIATION ::
   *     [Since 2.9] Set if the current face (or named instance) has been
   *     altered with \FT_Set_MM_Design_Coordinates,
   *     \FT_Set_Var_Design_Coordinates, or \FT_Set_Var_Blend_Coordinates.
   *     This flag is unset by a call to \FT_Set_Named_Instance.
   */
public static final long FT_FACE_FLAG_SCALABLE =          ( 1L <<  0 );
public static final long FT_FACE_FLAG_FIXED_SIZES =       ( 1L <<  1 );
public static final long FT_FACE_FLAG_FIXED_WIDTH =       ( 1L <<  2 );
public static final long FT_FACE_FLAG_SFNT =              ( 1L <<  3 );
public static final long FT_FACE_FLAG_HORIZONTAL =        ( 1L <<  4 );
public static final long FT_FACE_FLAG_VERTICAL =          ( 1L <<  5 );
public static final long FT_FACE_FLAG_KERNING =           ( 1L <<  6 );
public static final long FT_FACE_FLAG_FAST_GLYPHS =       ( 1L <<  7 );
public static final long FT_FACE_FLAG_MULTIPLE_MASTERS =  ( 1L <<  8 );
public static final long FT_FACE_FLAG_GLYPH_NAMES =       ( 1L <<  9 );
public static final long FT_FACE_FLAG_EXTERNAL_STREAM =   ( 1L << 10 );
public static final long FT_FACE_FLAG_HINTER =            ( 1L << 11 );
public static final long FT_FACE_FLAG_CID_KEYED =         ( 1L << 12 );
public static final long FT_FACE_FLAG_TRICKY =            ( 1L << 13 );
public static final long FT_FACE_FLAG_COLOR =             ( 1L << 14 );
public static final long FT_FACE_FLAG_VARIATION =         ( 1L << 15 );


  /**************************************************************************
   *
   * \macro:
   *   FT_HAS_HORIZONTAL
   *
   * \description:
   *   A macro that returns true whenever a face object contains horizontal
   *   metrics (this is true for all font formats though).
   *
   * \also:
   *   \FT_HAS_VERTICAL can be used to check for vertical metrics.
   *
   */
// #define FT_HAS_HORIZONTAL( face )
//           ( (face)->face_flags & FT_FACE_FLAG_HORIZONTAL )


  /**************************************************************************
   *
   * \macro:
   *   FT_HAS_VERTICAL
   *
   * \description:
   *   A macro that returns true whenever a face object contains real
   *   vertical metrics (and not only synthesized ones).
   *
   */
// #define FT_HAS_VERTICAL( face )
//           ( (face)->face_flags & FT_FACE_FLAG_VERTICAL )


  /**************************************************************************
   *
   * \macro:
   *   FT_HAS_KERNING
   *
   * \description:
   *   A macro that returns true whenever a face object contains kerning data
   *   that can be accessed with \FT_Get_Kerning.
   *
   */
// #define FT_HAS_KERNING( face )
//           ( (face)->face_flags & FT_FACE_FLAG_KERNING )


  /**************************************************************************
   *
   * \macro:
   *   FT_IS_SCALABLE
   *
   * \description:
   *   A macro that returns true whenever a face object contains a scalable
   *   font face (true for TrueType, Type~1, Type~42, CID, OpenType/CFF, and
   *   PFR font formats).
   *
   */
// #define FT_IS_SCALABLE( face )
//           ( (face)->face_flags & FT_FACE_FLAG_SCALABLE )


  /**************************************************************************
   *
   * \macro:
   *   FT_IS_SFNT
   *
   * \description:
   *   A macro that returns true whenever a face object contains a font whose
   *   format is based on the SFNT storage scheme.  This usually means:
   *   TrueType fonts, OpenType fonts, as well as SFNT-based embedded bitmap
   *   fonts.
   *
   *   If this macro is true, all functions defined in \FT_SFNT_NAMES_H and
   *   \FT_TRUETYPE_TABLES_H are available.
   *
   */
// #define FT_IS_SFNT( face )
//           ( (face)->face_flags & FT_FACE_FLAG_SFNT )


  /**************************************************************************
   *
   * \macro:
   *   FT_IS_FIXED_WIDTH
   *
   * \description:
   *   A macro that returns true whenever a face object contains a font face
   *   that contains fixed-width (or 'monospace', 'fixed-pitch', etc.)
   *   glyphs.
   *
   */
// #define FT_IS_FIXED_WIDTH( face )
//           ( (face)->face_flags & FT_FACE_FLAG_FIXED_WIDTH )


  /**************************************************************************
   *
   * \macro:
   *   FT_HAS_FIXED_SIZES
   *
   * \description:
   *   A macro that returns true whenever a face object contains some
   *   embedded bitmaps.  See the {@code available_sizes} field of the \FT_FaceRec
   *   structure.
   *
   */
// #define FT_HAS_FIXED_SIZES( face )
//           ( (face)->face_flags & FT_FACE_FLAG_FIXED_SIZES )


  /**************************************************************************
   *
   * \macro:
   *   FT_HAS_FAST_GLYPHS
   *
   * \description:
   *   Deprecated.
   *
   */
// #define FT_HAS_FAST_GLYPHS( face )  0


  /**************************************************************************
   *
   * \macro:
   *   FT_HAS_GLYPH_NAMES
   *
   * \description:
   *   A macro that returns true whenever a face object contains some glyph
   *   names that can be accessed through \FT_Get_Glyph_Name.
   *
   */
// #define FT_HAS_GLYPH_NAMES( face )
//           ( (face)->face_flags & FT_FACE_FLAG_GLYPH_NAMES )


  /**************************************************************************
   *
   * \macro:
   *   FT_HAS_MULTIPLE_MASTERS
   *
   * \description:
   *   A macro that returns true whenever a face object contains some
   *   multiple masters.  The functions provided by \FT_MULTIPLE_MASTERS_H
   *   are then available to choose the exact design you want.
   *
   */
// #define FT_HAS_MULTIPLE_MASTERS( face )
//           ( (face)->face_flags & FT_FACE_FLAG_MULTIPLE_MASTERS )


  /**************************************************************************
   *
   * \macro:
   *   FT_IS_NAMED_INSTANCE
   *
   * \description:
   *   A macro that returns true whenever a face object is a named instance
   *   of a GX or OpenType variation font.
   *
   *   [Since 2.9] Changing the design coordinates with
   *   \FT_Set_Var_Design_Coordinates or \FT_Set_Var_Blend_Coordinates does
   *   not influence the return value of this macro (only
   *   \FT_Set_Named_Instance does that).
   *
   * @since :
   *   2.7
   *
   */
// #define FT_IS_NAMED_INSTANCE( face )
//           ( (face)->face_index & 0x7FFF0000L )


  /**************************************************************************
   *
   * \macro:
   *   FT_IS_VARIATION
   *
   * \description:
   *   A macro that returns true whenever a face object has been altered by
   *   \FT_Set_MM_Design_Coordinates, \FT_Set_Var_Design_Coordinates, or
   *   \FT_Set_Var_Blend_Coordinates.
   *
   * @since :
   *   2.9
   *
   */
// #define FT_IS_VARIATION( face )
//           ( (face)->face_flags & FT_FACE_FLAG_VARIATION )


  /**************************************************************************
   *
   * \macro:
   *   FT_IS_CID_KEYED
   *
   * \description:
   *   A macro that returns true whenever a face object contains a CID-keyed
   *   font.  See the discussion of \FT_FACE_FLAG_CID_KEYED for more details.
   *
   *   If this macro is true, all functions defined in \FT_CID_H are
   *   available.
   *
   */
// #define FT_IS_CID_KEYED( face )
//           ( (face)->face_flags & FT_FACE_FLAG_CID_KEYED )


  /**************************************************************************
   *
   * \macro:
   *   FT_IS_TRICKY
   *
   * \description:
   *   A macro that returns true whenever a face represents a 'tricky' font.
   *   See the discussion of \FT_FACE_FLAG_TRICKY for more details.
   *
   */
// #define FT_IS_TRICKY( face )
//           ( (face)->face_flags & FT_FACE_FLAG_TRICKY )


  /**************************************************************************
   *
   * \macro:
   *   FT_HAS_COLOR
   *
   * \description:
   *   A macro that returns true whenever a face object contains tables for
   *   color glyphs.
   *
   * @since :
   *   2.5.1
   *
   */
// #define FT_HAS_COLOR( face )
//           ( (face)->face_flags & FT_FACE_FLAG_COLOR )


  /**************************************************************************
   *
   * \enum:
   *   FT_STYLE_FLAG_XXX
   *
   * \description:
   *   A list of bit flags to indicate the style of a given face.  These are
   *   used in the {@code style_flags} field of \FT_FaceRec.
   *
   * \values:
   *   FT_STYLE_FLAG_ITALIC ::
   *     The face style is italic or oblique.
   *
   *   FT_STYLE_FLAG_BOLD ::
   *     The face is bold.
   *
   * \note:
   *   The style information as provided by FreeType is very basic.  More
   *   details are beyond the scope and should be done on a higher level (for
   *   example, by analyzing various fields of the 'OS/2' table in SFNT based
   *   fonts).
   */
public static final int FT_STYLE_FLAG_ITALIC =  ( 1 << 0 );
public static final int FT_STYLE_FLAG_BOLD =    ( 1 << 1 );
// Targeting ../FT_Size_Internal.java


// Targeting ../FT_Size_Metrics.java


// Targeting ../FT_SizeRec.java


// Targeting ../FT_SubGlyph.java


// Targeting ../FT_Slot_Internal.java


// Targeting ../FT_GlyphSlotRec.java




  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                         F U N C T I O N S                             */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/


  /**************************************************************************
   *
   * \function:
   *   FT_Init_FreeType
   *
   * \description:
   *   Initialize a new FreeType library object.  The set of modules that are
   *   registered by this function is determined at build time.
   *
   * \output:
   *   alibrary ::
   *     A handle to a new library object.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   In case you want to provide your own memory allocating routines, use
   *   \FT_New_Library instead, followed by a call to \FT_Add_Default_Modules
   *   (or a series of calls to \FT_Add_Module) and
   *   \FT_Set_Default_Properties.
   *
   *   See the documentation of \FT_Library and \FT_Face for multi-threading
   *   issues.
   *
   *   If you need reference-counting (cf. \FT_Reference_Library), use
   *   \FT_New_Library and \FT_Done_Library.
   *
   *   If compilation option {@code FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES} is
   *   set, this function reads the {@code FREETYPE_PROPERTIES} environment
   *   variable to control driver properties.  See section \properties for
   *   more.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Done_FreeType
   *
   * \description:
   *   Destroy a given FreeType library object and all of its children,
   *   including resources, drivers, faces, sizes, etc.
   *
   * \input:
   *   library ::
   *     A handle to the target library object.
   *
   * @return :
   *   FreeType error code.  0~means success.
   */
  


  /**************************************************************************
   *
   * \enum:
   *   FT_OPEN_XXX
   *
   * \description:
   *   A list of bit field constants used within the {@code flags} field of the
   *   \FT_Open_Args structure.
   *
   * \values:
   *   FT_OPEN_MEMORY ::
   *     This is a memory-based stream.
   *
   *   FT_OPEN_STREAM ::
   *     Copy the stream from the {@code stream} field.
   *
   *   FT_OPEN_PATHNAME ::
   *     Create a new input stream from a C~path name.
   *
   *   FT_OPEN_DRIVER ::
   *     Use the {@code driver} field.
   *
   *   FT_OPEN_PARAMS ::
   *     Use the {@code num_params} and {@code params} fields.
   *
   * \note:
   *   The {@code FT_OPEN_MEMORY}, {@code FT_OPEN_STREAM}, and {@code FT_OPEN_PATHNAME} flags
   *   are mutually exclusive.
   */
public static final int FT_OPEN_MEMORY =    0x1;
public static final int FT_OPEN_STREAM =    0x2;
public static final int FT_OPEN_PATHNAME =  0x4;
public static final int FT_OPEN_DRIVER =    0x8;
public static final int FT_OPEN_PARAMS =    0x10;


  /* these constants are deprecated; use the corresponding `FT_OPEN_XXX` */
  /* values instead                                                      */
public static final int ft_open_memory =    FT_OPEN_MEMORY;
public static final int ft_open_stream =    FT_OPEN_STREAM;
public static final int ft_open_pathname =  FT_OPEN_PATHNAME;
public static final int ft_open_driver =    FT_OPEN_DRIVER;
public static final int ft_open_params =    FT_OPEN_PARAMS;
// Targeting ../FT_Parameter.java


// Targeting ../FT_Open_Args.java




  /**************************************************************************
   *
   * \function:
   *   FT_New_Face
   *
   * \description:
   *   Call \FT_Open_Face to open a font by its pathname.
   *
   * \inout:
   *   library ::
   *     A handle to the library resource.
   *
   * \input:
   *   pathname ::
   *     A path to the font file.
   *
   *   face_index ::
   *     See \FT_Open_Face for a detailed description of this parameter.
   *
   * \output:
   *   aface ::
   *     A handle to a new face object.  If {@code face_index} is greater than or
   *     equal to zero, it must be non-{@code NULL}.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   Use \FT_Done_Face to destroy the created \FT_Face object (along with
   *   its slot and sizes).
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_New_Memory_Face
   *
   * \description:
   *   Call \FT_Open_Face to open a font that has been loaded into memory.
   *
   * \inout:
   *   library ::
   *     A handle to the library resource.
   *
   * \input:
   *   file_base ::
   *     A pointer to the beginning of the font data.
   *
   *   file_size ::
   *     The size of the memory chunk used by the font data.
   *
   *   face_index ::
   *     See \FT_Open_Face for a detailed description of this parameter.
   *
   * \output:
   *   aface ::
   *     A handle to a new face object.  If {@code face_index} is greater than or
   *     equal to zero, it must be non-{@code NULL}.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   You must not deallocate the memory before calling \FT_Done_Face.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Open_Face
   *
   * \description:
   *   Create a face object from a given resource described by \FT_Open_Args.
   *
   * \inout:
   *   library ::
   *     A handle to the library resource.
   *
   * \input:
   *   args ::
   *     A pointer to an {@code FT_Open_Args} structure that must be filled by the
   *     caller.
   *
   *   face_index ::
   *     This field holds two different values.  Bits 0-15 are the index of
   *     the face in the font file (starting with value~0).  Set it to~0 if
   *     there is only one face in the font file.
   *
   *     [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation
   *     fonts only, specifying the named instance index for the current face
   *     index (starting with value~1; value~0 makes FreeType ignore named
   *     instances).  For non-variation fonts, bits 16-30 are ignored.
   *     Assuming that you want to access the third named instance in face~4,
   *     {@code face_index} should be set to 0x00030004.  If you want to access
   *     face~4 without variation handling, simply set {@code face_index} to
   *     value~4.
   *
   *     {@code FT_Open_Face} and its siblings can be used to quickly check whether
   *     the font format of a given font resource is supported by FreeType.
   *     In general, if the {@code face_index} argument is negative, the function's
   *     return value is~0 if the font format is recognized, or non-zero
   *     otherwise.  The function allocates a more or less empty face handle
   *     in {@code *aface} (if {@code aface} isn't {@code NULL}); the only two useful fields in
   *     this special case are {@code face->num_faces} and {@code face->style_flags}.
   *     For any negative value of {@code face_index}, {@code face->num_faces} gives the
   *     number of faces within the font file.  For the negative value
   *     '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in
   *     {@code face->style_flags} give the number of named instances in face 'N'
   *     if we have a variation font (or zero otherwise).  After examination,
   *     the returned \FT_Face structure should be deallocated with a call to
   *     \FT_Done_Face.
   *
   * \output:
   *   aface ::
   *     A handle to a new face object.  If {@code face_index} is greater than or
   *     equal to zero, it must be non-{@code NULL}.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   Unlike FreeType 1.x, this function automatically creates a glyph slot
   *   for the face object that can be accessed directly through
   *   {@code face->glyph}.
   *
   *   Each new face object created with this function also owns a default
   *   \FT_Size object, accessible as {@code face->size}.
   *
   *   One \FT_Library instance can have multiple face objects, this is,
   *   \FT_Open_Face and its siblings can be called multiple times using the
   *   same {@code library} argument.
   *
   *   See the discussion of reference counters in the description of
   *   \FT_Reference_Face.
   *
   * \example:
   *   To loop over all faces, use code similar to the following snippet
   *   (omitting the error handling).
   *
   *   <pre>{@code
   *     ...
   *     FT_Face  face;
   *     FT_Long  i, num_faces;
   *
   *
   *     error = FT_Open_Face( library, args, -1, &face );
   *     if ( error ) { ... }
   *
   *     num_faces = face->num_faces;
   *     FT_Done_Face( face );
   *
   *     for ( i = 0; i < num_faces; i++ )
   *     {
   *       ...
   *       error = FT_Open_Face( library, args, i, &face );
   *       ...
   *       FT_Done_Face( face );
   *       ...
   *     }
   *   }</pre>
   *
   *   To loop over all valid values for {@code face_index}, use something similar
   *   to the following snippet, again without error handling.  The code
   *   accesses all faces immediately (thus only a single call of
   *   {@code FT_Open_Face} within the do-loop), with and without named instances.
   *
   *   <pre>{@code
   *     ...
   *     FT_Face  face;
   *
   *     FT_Long  num_faces     = 0;
   *     FT_Long  num_instances = 0;
   *
   *     FT_Long  face_idx     = 0;
   *     FT_Long  instance_idx = 0;
   *
   *
   *     do
   *     {
   *       FT_Long  id = ( instance_idx << 16 ) + face_idx;
   *
   *
   *       error = FT_Open_Face( library, args, id, &face );
   *       if ( error ) { ... }
   *
   *       num_faces     = face->num_faces;
   *       num_instances = face->style_flags >> 16;
   *
   *       ...
   *
   *       FT_Done_Face( face );
   *
   *       if ( instance_idx < num_instances )
   *         instance_idx++;
   *       else
   *       {
   *         face_idx++;
   *         instance_idx = 0;
   *       }
   *
   *     } while ( face_idx < num_faces )
   *   }</pre>
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Attach_File
   *
   * \description:
   *   Call \FT_Attach_Stream to attach a file.
   *
   * \inout:
   *   face ::
   *     The target face object.
   *
   * \input:
   *   filepathname ::
   *     The pathname.
   *
   * @return :
   *   FreeType error code.  0~means success.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Attach_Stream
   *
   * \description:
   *   'Attach' data to a face object.  Normally, this is used to read
   *   additional information for the face object.  For example, you can
   *   attach an AFM file that comes with a Type~1 font to get the kerning
   *   values and other metrics.
   *
   * \inout:
   *   face ::
   *     The target face object.
   *
   * \input:
   *   parameters ::
   *     A pointer to \FT_Open_Args that must be filled by the caller.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   The meaning of the 'attach' (i.e., what really happens when the new
   *   file is read) is not fixed by FreeType itself.  It really depends on
   *   the font format (and thus the font driver).
   *
   *   Client applications are expected to know what they are doing when
   *   invoking this function.  Most drivers simply do not implement file or
   *   stream attachments.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Reference_Face
   *
   * \description:
   *   A counter gets initialized to~1 at the time an \FT_Face structure is
   *   created.  This function increments the counter.  \FT_Done_Face then
   *   only destroys a face if the counter is~1, otherwise it simply
   *   decrements the counter.
   *
   *   This function helps in managing life-cycles of structures that
   *   reference \FT_Face objects.
   *
   * \input:
   *   face ::
   *     A handle to a target face object.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * @since :
   *   2.4.2
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Done_Face
   *
   * \description:
   *   Discard a given face object, as well as all of its child slots and
   *   sizes.
   *
   * \input:
   *   face ::
   *     A handle to a target face object.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   See the discussion of reference counters in the description of
   *   \FT_Reference_Face.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Select_Size
   *
   * \description:
   *   Select a bitmap strike.  To be more precise, this function sets the
   *   scaling factors of the active \FT_Size object in a face so that
   *   bitmaps from this particular strike are taken by \FT_Load_Glyph and
   *   friends.
   *
   * \inout:
   *   face ::
   *     A handle to a target face object.
   *
   * \input:
   *   strike_index ::
   *     The index of the bitmap strike in the {@code available_sizes} field of
   *     \FT_FaceRec structure.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   For bitmaps embedded in outline fonts it is common that only a subset
   *   of the available glyphs at a given ppem value is available.  FreeType
   *   silently uses outlines if there is no bitmap for a given glyph index.
   *
   *   For GX and OpenType variation fonts, a bitmap strike makes sense only
   *   if the default instance is active (this is, no glyph variation takes
   *   place); otherwise, FreeType simply ignores bitmap strikes.  The same
   *   is true for all named instances that are different from the default
   *   instance.
   *
   *   Don't use this function if you are using the FreeType cache API.
   */
  


  /**************************************************************************
   *
   * \enum:
   *   FT_Size_Request_Type
   *
   * \description:
   *   An enumeration type that lists the supported size request types, i.e.,
   *   what input size (in font units) maps to the requested output size (in
   *   pixels, as computed from the arguments of \FT_Size_Request).
   *
   * \values:
   *   FT_SIZE_REQUEST_TYPE_NOMINAL ::
   *     The nominal size.  The {@code units_per_EM} field of \FT_FaceRec is used
   *     to determine both scaling values.
   *
   *     This is the standard scaling found in most applications.  In
   *     particular, use this size request type for TrueType fonts if they
   *     provide optical scaling or something similar.  Note, however, that
   *     {@code units_per_EM} is a rather abstract value which bears no relation to
   *     the actual size of the glyphs in a font.
   *
   *   FT_SIZE_REQUEST_TYPE_REAL_DIM ::
   *     The real dimension.  The sum of the {@code ascender} and (minus of) the
   *     {@code descender} fields of \FT_FaceRec is used to determine both scaling
   *     values.
   *
   *   FT_SIZE_REQUEST_TYPE_BBOX ::
   *     The font bounding box.  The width and height of the {@code bbox} field of
   *     \FT_FaceRec are used to determine the horizontal and vertical
   *     scaling value, respectively.
   *
   *   FT_SIZE_REQUEST_TYPE_CELL ::
   *     The {@code max_advance_width} field of \FT_FaceRec is used to determine
   *     the horizontal scaling value; the vertical scaling value is
   *     determined the same way as \FT_SIZE_REQUEST_TYPE_REAL_DIM does.
   *     Finally, both scaling values are set to the smaller one.  This type
   *     is useful if you want to specify the font size for, say, a window of
   *     a given dimension and 80x24 cells.
   *
   *   FT_SIZE_REQUEST_TYPE_SCALES ::
   *     Specify the scaling values directly.
   *
   * \note:
   *   The above descriptions only apply to scalable formats.  For bitmap
   *   formats, the behaviour is up to the driver.
   *
   *   See the note section of \FT_Size_Metrics if you wonder how size
   *   requesting relates to scaling values.
   */
  /** enum FT_Size_Request_Type_ */
  public static final int
    FT_SIZE_REQUEST_TYPE_NOMINAL = 0,
    FT_SIZE_REQUEST_TYPE_REAL_DIM = 1,
    FT_SIZE_REQUEST_TYPE_BBOX = 2,
    FT_SIZE_REQUEST_TYPE_CELL = 3,
    FT_SIZE_REQUEST_TYPE_SCALES = 4,

    FT_SIZE_REQUEST_TYPE_MAX = 5;
// Targeting ../FT_Size_RequestRec.java


// Targeting ../FT_Size_RequestRec_.java




  /**************************************************************************
   *
   * \function:
   *   FT_Request_Size
   *
   * \description:
   *   Resize the scale of the active \FT_Size object in a face.
   *
   * \inout:
   *   face ::
   *     A handle to a target face object.
   *
   * \input:
   *   req ::
   *     A pointer to a \FT_Size_RequestRec.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   Although drivers may select the bitmap strike matching the request,
   *   you should not rely on this if you intend to select a particular
   *   bitmap strike.  Use \FT_Select_Size instead in that case.
   *
   *   The relation between the requested size and the resulting glyph size
   *   is dependent entirely on how the size is defined in the source face.
   *   The font designer chooses the final size of each glyph relative to
   *   this size.  For more information refer to
   *   'https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.
   *
   *   Contrary to \FT_Set_Char_Size, this function doesn't have special code
   *   to normalize zero-valued widths, heights, or resolutions (which lead
   *   to errors in most cases).
   *
   *   Don't use this function if you are using the FreeType cache API.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Set_Char_Size
   *
   * \description:
   *   Call \FT_Request_Size to request the nominal size (in points).
   *
   * \inout:
   *   face ::
   *     A handle to a target face object.
   *
   * \input:
   *   char_width ::
   *     The nominal width, in 26.6 fractional points.
   *
   *   char_height ::
   *     The nominal height, in 26.6 fractional points.
   *
   *   horz_resolution ::
   *     The horizontal resolution in dpi.
   *
   *   vert_resolution ::
   *     The vertical resolution in dpi.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   While this function allows fractional points as input values, the
   *   resulting ppem value for the given resolution is always rounded to the
   *   nearest integer.
   *
   *   If either the character width or height is zero, it is set equal to
   *   the other value.
   *
   *   If either the horizontal or vertical resolution is zero, it is set
   *   equal to the other value.
   *
   *   A character width or height smaller than 1pt is set to 1pt; if both
   *   resolution values are zero, they are set to 72dpi.
   *
   *   Don't use this function if you are using the FreeType cache API.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Set_Pixel_Sizes
   *
   * \description:
   *   Call \FT_Request_Size to request the nominal size (in pixels).
   *
   * \inout:
   *   face ::
   *     A handle to the target face object.
   *
   * \input:
   *   pixel_width ::
   *     The nominal width, in pixels.
   *
   *   pixel_height ::
   *     The nominal height, in pixels.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   You should not rely on the resulting glyphs matching or being
   *   constrained to this pixel size.  Refer to \FT_Request_Size to
   *   understand how requested sizes relate to actual sizes.
   *
   *   Don't use this function if you are using the FreeType cache API.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Load_Glyph
   *
   * \description:
   *   Load a glyph into the glyph slot of a face object.
   *
   * \inout:
   *   face ::
   *     A handle to the target face object where the glyph is loaded.
   *
   * \input:
   *   glyph_index ::
   *     The index of the glyph in the font file.  For CID-keyed fonts
   *     (either in PS or in CFF format) this argument specifies the CID
   *     value.
   *
   *   load_flags ::
   *     A flag indicating what to load for this glyph.  The \FT_LOAD_XXX
   *     constants can be used to control the glyph loading process (e.g.,
   *     whether the outline should be scaled, whether to load bitmaps or
   *     not, whether to hint the outline, etc).
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   The loaded glyph may be transformed.  See \FT_Set_Transform for the
   *   details.
   *
   *   For subsetted CID-keyed fonts, {@code FT_Err_Invalid_Argument} is returned
   *   for invalid CID values (this is, for CID values that don't have a
   *   corresponding glyph in the font).  See the discussion of the
   *   \FT_FACE_FLAG_CID_KEYED flag for more details.
   *
   *   If you receive {@code FT_Err_Glyph_Too_Big}, try getting the glyph outline
   *   at EM size, then scale it manually and fill it as a graphics
   *   operation.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Load_Char
   *
   * \description:
   *   Load a glyph into the glyph slot of a face object, accessed by its
   *   character code.
   *
   * \inout:
   *   face ::
   *     A handle to a target face object where the glyph is loaded.
   *
   * \input:
   *   char_code ::
   *     The glyph's character code, according to the current charmap used in
   *     the face.
   *
   *   load_flags ::
   *     A flag indicating what to load for this glyph.  The \FT_LOAD_XXX
   *     constants can be used to control the glyph loading process (e.g.,
   *     whether the outline should be scaled, whether to load bitmaps or
   *     not, whether to hint the outline, etc).
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   This function simply calls \FT_Get_Char_Index and \FT_Load_Glyph.
   *
   *   Many fonts contain glyphs that can't be loaded by this function since
   *   its glyph indices are not listed in any of the font's charmaps.
   *
   *   If no active cmap is set up (i.e., {@code face->charmap} is zero), the call
   *   to \FT_Get_Char_Index is omitted, and the function behaves identically
   *   to \FT_Load_Glyph.
   */
  


  /**************************************************************************
   *
   * \enum:
   *   FT_LOAD_XXX
   *
   * \description:
   *   A list of bit field constants for \FT_Load_Glyph to indicate what kind
   *   of operations to perform during glyph loading.
   *
   * \values:
   *   FT_LOAD_DEFAULT ::
   *     Corresponding to~0, this value is used as the default glyph load
   *     operation.  In this case, the following happens:
   *
   *     1. FreeType looks for a bitmap for the glyph corresponding to the
   *     face's current size.  If one is found, the function returns.  The
   *     bitmap data can be accessed from the glyph slot (see note below).
   *
   *     2. If no embedded bitmap is searched for or found, FreeType looks
   *     for a scalable outline.  If one is found, it is loaded from the font
   *     file, scaled to device pixels, then 'hinted' to the pixel grid in
   *     order to optimize it.  The outline data can be accessed from the
   *     glyph slot (see note below).
   *
   *     Note that by default the glyph loader doesn't render outlines into
   *     bitmaps.  The following flags are used to modify this default
   *     behaviour to more specific and useful cases.
   *
   *   FT_LOAD_NO_SCALE ::
   *     Don't scale the loaded outline glyph but keep it in font units.
   *
   *     This flag implies \FT_LOAD_NO_HINTING and \FT_LOAD_NO_BITMAP, and
   *     unsets \FT_LOAD_RENDER.
   *
   *     If the font is 'tricky' (see \FT_FACE_FLAG_TRICKY for more), using
   *     {@code FT_LOAD_NO_SCALE} usually yields meaningless outlines because the
   *     subglyphs must be scaled and positioned with hinting instructions. 
   *     This can be solved by loading the font without {@code FT_LOAD_NO_SCALE}
   *     and setting the character size to {@code font->units_per_EM}.
   *
   *   FT_LOAD_NO_HINTING ::
   *     Disable hinting.  This generally generates 'blurrier' bitmap glyphs
   *     when the glyph are rendered in any of the anti-aliased modes.  See
   *     also the note below.
   *
   *     This flag is implied by \FT_LOAD_NO_SCALE.
   *
   *   FT_LOAD_RENDER ::
   *     Call \FT_Render_Glyph after the glyph is loaded.  By default, the
   *     glyph is rendered in \FT_RENDER_MODE_NORMAL mode.  This can be
   *     overridden by \FT_LOAD_TARGET_XXX or \FT_LOAD_MONOCHROME.
   *
   *     This flag is unset by \FT_LOAD_NO_SCALE.
   *
   *   FT_LOAD_NO_BITMAP ::
   *     Ignore bitmap strikes when loading.  Bitmap-only fonts ignore this
   *     flag.
   *
   *     \FT_LOAD_NO_SCALE always sets this flag.
   *
   *   FT_LOAD_VERTICAL_LAYOUT ::
   *     Load the glyph for vertical text layout.  In particular, the
   *     {@code advance} value in the \FT_GlyphSlotRec structure is set to the
   *     {@code vertAdvance} value of the {@code metrics} field.
   *
   *     In case \FT_HAS_VERTICAL doesn't return true, you shouldn't use this
   *     flag currently.  Reason is that in this case vertical metrics get
   *     synthesized, and those values are not always consistent across
   *     various font formats.
   *
   *   FT_LOAD_FORCE_AUTOHINT ::
   *     Prefer the auto-hinter over the font's native hinter.  See also the
   *     note below.
   *
   *   FT_LOAD_PEDANTIC ::
   *     Make the font driver perform pedantic verifications during glyph
   *     loading and hinting.  This is mostly used to detect broken glyphs in
   *     fonts.  By default, FreeType tries to handle broken fonts also.
   *
   *     In particular, errors from the TrueType bytecode engine are not
   *     passed to the application if this flag is not set; this might result
   *     in partially hinted or distorted glyphs in case a glyph's bytecode
   *     is buggy.
   *
   *   FT_LOAD_NO_RECURSE ::
   *     Don't load composite glyphs recursively.  Instead, the font driver
   *     fills the {@code num_subglyph} and {@code subglyphs} values of the glyph slot;
   *     it also sets {@code glyph->format} to \FT_GLYPH_FORMAT_COMPOSITE.  The
   *     description of subglyphs can then be accessed with
   *     \FT_Get_SubGlyph_Info.
   *
   *     Don't use this flag for retrieving metrics information since some
   *     font drivers only return rudimentary data.
   *
   *     This flag implies \FT_LOAD_NO_SCALE and \FT_LOAD_IGNORE_TRANSFORM.
   *
   *   FT_LOAD_IGNORE_TRANSFORM ::
   *     Ignore the transform matrix set by \FT_Set_Transform.
   *
   *   FT_LOAD_MONOCHROME ::
   *     This flag is used with \FT_LOAD_RENDER to indicate that you want to
   *     render an outline glyph to a 1-bit monochrome bitmap glyph, with
   *     8~pixels packed into each byte of the bitmap data.
   *
   *     Note that this has no effect on the hinting algorithm used.  You
   *     should rather use \FT_LOAD_TARGET_MONO so that the
   *     monochrome-optimized hinting algorithm is used.
   *
   *   FT_LOAD_LINEAR_DESIGN ::
   *     Keep {@code linearHoriAdvance} and {@code linearVertAdvance} fields of
   *     \FT_GlyphSlotRec in font units.  See \FT_GlyphSlotRec for details.
   *
   *   FT_LOAD_NO_AUTOHINT ::
   *     Disable the auto-hinter.  See also the note below.
   *
   *   FT_LOAD_COLOR ::
   *     Load colored glyphs.  There are slight differences depending on the
   *     font format.
   *
   *     [Since 2.5] Load embedded color bitmap images.  The resulting color
   *     bitmaps, if available, will have the \FT_PIXEL_MODE_BGRA format,
   *     with pre-multiplied color channels.  If the flag is not set and
   *     color bitmaps are found, they are converted to 256-level gray
   *     bitmaps, using the \FT_PIXEL_MODE_GRAY format.
   *
   *     [Since 2.10, experimental] If the glyph index contains an entry in
   *     the face's 'COLR' table with a 'CPAL' palette table (as defined in
   *     the OpenType specification), make \FT_Render_Glyph provide a default
   *     blending of the color glyph layers associated with the glyph index,
   *     using the same bitmap format as embedded color bitmap images.  This
   *     is mainly for convenience; for full control of color layers use
   *     \FT_Get_Color_Glyph_Layer and FreeType's color functions like
   *     \FT_Palette_Select instead of setting \FT_LOAD_COLOR for rendering
   *     so that the client application can handle blending by itself.
   *
   *   FT_LOAD_COMPUTE_METRICS ::
   *     [Since 2.6.1] Compute glyph metrics from the glyph data, without the
   *     use of bundled metrics tables (for example, the 'hdmx' table in
   *     TrueType fonts).  This flag is mainly used by font validating or
   *     font editing applications, which need to ignore, verify, or edit
   *     those tables.
   *
   *     Currently, this flag is only implemented for TrueType fonts.
   *
   *   FT_LOAD_BITMAP_METRICS_ONLY ::
   *     [Since 2.7.1] Request loading of the metrics and bitmap image
   *     information of a (possibly embedded) bitmap glyph without allocating
   *     or copying the bitmap image data itself.  No effect if the target
   *     glyph is not a bitmap image.
   *
   *     This flag unsets \FT_LOAD_RENDER.
   *
   *   FT_LOAD_CROP_BITMAP ::
   *     Ignored.  Deprecated.
   *
   *   FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ::
   *     Ignored.  Deprecated.
   *
   * \note:
   *   By default, hinting is enabled and the font's native hinter (see
   *   \FT_FACE_FLAG_HINTER) is preferred over the auto-hinter.  You can
   *   disable hinting by setting \FT_LOAD_NO_HINTING or change the
   *   precedence by setting \FT_LOAD_FORCE_AUTOHINT.  You can also set
   *   \FT_LOAD_NO_AUTOHINT in case you don't want the auto-hinter to be used
   *   at all.
   *
   *   See the description of \FT_FACE_FLAG_TRICKY for a special exception
   *   (affecting only a handful of Asian fonts).
   *
   *   Besides deciding which hinter to use, you can also decide which
   *   hinting algorithm to use.  See \FT_LOAD_TARGET_XXX for details.
   *
   *   Note that the auto-hinter needs a valid Unicode cmap (either a native
   *   one or synthesized by FreeType) for producing correct results.  If a
   *   font provides an incorrect mapping (for example, assigning the
   *   character code U+005A, LATIN CAPITAL LETTER~Z, to a glyph depicting a
   *   mathematical integral sign), the auto-hinter might produce useless
   *   results.
   *
   */
public static final int FT_LOAD_DEFAULT =                      0x0;
public static final long FT_LOAD_NO_SCALE =                     ( 1L << 0 );
public static final long FT_LOAD_NO_HINTING =                   ( 1L << 1 );
public static final long FT_LOAD_RENDER =                       ( 1L << 2 );
public static final long FT_LOAD_NO_BITMAP =                    ( 1L << 3 );
public static final long FT_LOAD_VERTICAL_LAYOUT =              ( 1L << 4 );
public static final long FT_LOAD_FORCE_AUTOHINT =               ( 1L << 5 );
public static final long FT_LOAD_CROP_BITMAP =                  ( 1L << 6 );
public static final long FT_LOAD_PEDANTIC =                     ( 1L << 7 );
public static final long FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH =  ( 1L << 9 );
public static final long FT_LOAD_NO_RECURSE =                   ( 1L << 10 );
public static final long FT_LOAD_IGNORE_TRANSFORM =             ( 1L << 11 );
public static final long FT_LOAD_MONOCHROME =                   ( 1L << 12 );
public static final long FT_LOAD_LINEAR_DESIGN =                ( 1L << 13 );
public static final long FT_LOAD_NO_AUTOHINT =                  ( 1L << 15 );
  /* Bits 16-19 are used by `FT_LOAD_TARGET_` */
public static final long FT_LOAD_COLOR =                        ( 1L << 20 );
public static final long FT_LOAD_COMPUTE_METRICS =              ( 1L << 21 );
public static final long FT_LOAD_BITMAP_METRICS_ONLY =          ( 1L << 22 );

  /* */

  /* used internally only by certain font drivers */
public static final long FT_LOAD_ADVANCE_ONLY =                 ( 1L << 8 );
public static final long FT_LOAD_SBITS_ONLY =                   ( 1L << 14 );


  /**************************************************************************
   *
   * \enum:
   *   FT_LOAD_TARGET_XXX
   *
   * \description:
   *   A list of values to select a specific hinting algorithm for the
   *   hinter.  You should OR one of these values to your {@code load_flags} when
   *   calling \FT_Load_Glyph.
   *
   *   Note that a font's native hinters may ignore the hinting algorithm you
   *   have specified (e.g., the TrueType bytecode interpreter).  You can set
   *   \FT_LOAD_FORCE_AUTOHINT to ensure that the auto-hinter is used.
   *
   * \values:
   *   FT_LOAD_TARGET_NORMAL ::
   *     The default hinting algorithm, optimized for standard gray-level
   *     rendering.  For monochrome output, use \FT_LOAD_TARGET_MONO instead.
   *
   *   FT_LOAD_TARGET_LIGHT ::
   *     A lighter hinting algorithm for gray-level modes.  Many generated
   *     glyphs are fuzzier but better resemble their original shape.  This
   *     is achieved by snapping glyphs to the pixel grid only vertically
   *     (Y-axis), as is done by FreeType's new CFF engine or Microsoft's
   *     ClearType font renderer.  This preserves inter-glyph spacing in
   *     horizontal text.  The snapping is done either by the native font
   *     driver, if the driver itself and the font support it, or by the
   *     auto-hinter.
   *
   *     Advance widths are rounded to integer values; however, using the
   *     {@code lsb_delta} and {@code rsb_delta} fields of \FT_GlyphSlotRec, it is
   *     possible to get fractional advance widths for subpixel positioning
   *     (which is recommended to use).
   *
   *     If configuration option {@code AF_CONFIG_OPTION_TT_SIZE_METRICS} is
   *     active, TrueType-like metrics are used to make this mode behave
   *     similarly as in unpatched FreeType versions between 2.4.6 and 2.7.1
   *     (inclusive).
   *
   *   FT_LOAD_TARGET_MONO ::
   *     Strong hinting algorithm that should only be used for monochrome
   *     output.  The result is probably unpleasant if the glyph is rendered
   *     in non-monochrome modes.
   *
   *     Note that for outline fonts only the TrueType font driver has proper
   *     monochrome hinting support, provided the TTFs contain hints for B/W
   *     rendering (which most fonts no longer provide).  If these conditions
   *     are not met it is very likely that you get ugly results at smaller
   *     sizes.
   *
   *   FT_LOAD_TARGET_LCD ::
   *     A variant of \FT_LOAD_TARGET_LIGHT optimized for horizontally
   *     decimated LCD displays.
   *
   *   FT_LOAD_TARGET_LCD_V ::
   *     A variant of \FT_LOAD_TARGET_NORMAL optimized for vertically
   *     decimated LCD displays.
   *
   * \note:
   *   You should use only _one_ of the {@code FT_LOAD_TARGET_XXX} values in your
   *   {@code load_flags}.  They can't be ORed.
   *
   *   If \FT_LOAD_RENDER is also set, the glyph is rendered in the
   *   corresponding mode (i.e., the mode that matches the used algorithm
   *   best).  An exception is {@code FT_LOAD_TARGET_MONO} since it implies
   *   \FT_LOAD_MONOCHROME.
   *
   *   You can use a hinting algorithm that doesn't correspond to the same
   *   rendering mode.  As an example, it is possible to use the 'light'
   *   hinting algorithm and have the results rendered in horizontal LCD
   *   pixel mode, with code like
   *
   *   <pre>{@code
   *     FT_Load_Glyph( face, glyph_index,
   *                    load_flags | FT_LOAD_TARGET_LIGHT );
   *
   *     FT_Render_Glyph( face->glyph, FT_RENDER_MODE_LCD );
   *   }</pre>
   *
   *   In general, you should stick with one rendering mode.  For example,
   *   switching between \FT_LOAD_TARGET_NORMAL and \FT_LOAD_TARGET_MONO
   *   enforces a lot of recomputation for TrueType fonts, which is slow.
   *   Another reason is caching: Selecting a different mode usually causes
   *   changes in both the outlines and the rasterized bitmaps; it is thus
   *   necessary to empty the cache after a mode switch to avoid false hits.
   *
   */
// #define FT_LOAD_TARGET_( x )   ( (FT_Int32)( (x) & 15 ) << 16 )

public static native @MemberGetter int FT_LOAD_TARGET_NORMAL();
public static final int FT_LOAD_TARGET_NORMAL = FT_LOAD_TARGET_NORMAL();
public static native @MemberGetter int FT_LOAD_TARGET_LIGHT();
public static final int FT_LOAD_TARGET_LIGHT = FT_LOAD_TARGET_LIGHT();
public static native @MemberGetter int FT_LOAD_TARGET_MONO();
public static final int FT_LOAD_TARGET_MONO = FT_LOAD_TARGET_MONO();
public static native @MemberGetter int FT_LOAD_TARGET_LCD();
public static final int FT_LOAD_TARGET_LCD = FT_LOAD_TARGET_LCD();
public static native @MemberGetter int FT_LOAD_TARGET_LCD_V();
public static final int FT_LOAD_TARGET_LCD_V = FT_LOAD_TARGET_LCD_V();


  /**************************************************************************
   *
   * \macro:
   *   FT_LOAD_TARGET_MODE
   *
   * \description:
   *   Return the \FT_Render_Mode corresponding to a given
   *   \FT_LOAD_TARGET_XXX value.
   *
   */
// #define FT_LOAD_TARGET_MODE( x )  ( (FT_Render_Mode)( ( (x) >> 16 ) & 15 ) )


  /**************************************************************************
   *
   * \function:
   *   FT_Set_Transform
   *
   * \description:
   *   Set the transformation that is applied to glyph images when they are
   *   loaded into a glyph slot through \FT_Load_Glyph.
   *
   * \inout:
   *   face ::
   *     A handle to the source face object.
   *
   * \input:
   *   matrix ::
   *     A pointer to the transformation's 2x2 matrix.  Use {@code NULL} for the
   *     identity matrix.
   *   delta ::
   *     A pointer to the translation vector.  Use {@code NULL} for the null vector.
   *
   * \note:
   *   The transformation is only applied to scalable image formats after the
   *   glyph has been loaded.  It means that hinting is unaltered by the
   *   transformation and is performed on the character size given in the
   *   last call to \FT_Set_Char_Size or \FT_Set_Pixel_Sizes.
   *
   *   Note that this also transforms the {@code face.glyph.advance} field, but
   *   **not** the values in {@code face.glyph.metrics}.
   */
  


  /**************************************************************************
   *
   * \enum:
   *   FT_Render_Mode
   *
   * \description:
   *   Render modes supported by FreeType~2.  Each mode corresponds to a
   *   specific type of scanline conversion performed on the outline.
   *
   *   For bitmap fonts and embedded bitmaps the {@code bitmap->pixel_mode} field
   *   in the \FT_GlyphSlotRec structure gives the format of the returned
   *   bitmap.
   *
   *   All modes except \FT_RENDER_MODE_MONO use 256 levels of opacity,
   *   indicating pixel coverage.  Use linear alpha blending and gamma
   *   correction to correctly render non-monochrome glyph bitmaps onto a
   *   surface; see \FT_Render_Glyph.
   *
   * \values:
   *   FT_RENDER_MODE_NORMAL ::
   *     Default render mode; it corresponds to 8-bit anti-aliased bitmaps.
   *
   *   FT_RENDER_MODE_LIGHT ::
   *     This is equivalent to \FT_RENDER_MODE_NORMAL.  It is only defined as
   *     a separate value because render modes are also used indirectly to
   *     define hinting algorithm selectors.  See \FT_LOAD_TARGET_XXX for
   *     details.
   *
   *   FT_RENDER_MODE_MONO ::
   *     This mode corresponds to 1-bit bitmaps (with 2~levels of opacity).
   *
   *   FT_RENDER_MODE_LCD ::
   *     This mode corresponds to horizontal RGB and BGR subpixel displays
   *     like LCD screens.  It produces 8-bit bitmaps that are 3~times the
   *     width of the original glyph outline in pixels, and which use the
   *     \FT_PIXEL_MODE_LCD mode.
   *
   *   FT_RENDER_MODE_LCD_V ::
   *     This mode corresponds to vertical RGB and BGR subpixel displays
   *     (like PDA screens, rotated LCD displays, etc.).  It produces 8-bit
   *     bitmaps that are 3~times the height of the original glyph outline in
   *     pixels and use the \FT_PIXEL_MODE_LCD_V mode.
   *
   * \note:
   *   Should you define {@code FT_CONFIG_OPTION_SUBPIXEL_RENDERING} in your
   *   {@code ftoption.h}, which enables patented ClearType-style rendering, the
   *   LCD-optimized glyph bitmaps should be filtered to reduce color fringes
   *   inherent to this technology.  You can either set up LCD filtering with
   *   \FT_Library_SetLcdFilter or \FT_Face_Properties, or do the filtering
   *   yourself.  The default FreeType LCD rendering technology does not
   *   require filtering.
   *
   *   The selected render mode only affects vector glyphs of a font.
   *   Embedded bitmaps often have a different pixel mode like
   *   \FT_PIXEL_MODE_MONO.  You can use \FT_Bitmap_Convert to transform them
   *   into 8-bit pixmaps.
   */
  /** enum FT_Render_Mode_ */
  public static final int
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT = 1,
    FT_RENDER_MODE_MONO = 2,
    FT_RENDER_MODE_LCD = 3,
    FT_RENDER_MODE_LCD_V = 4,

    FT_RENDER_MODE_MAX = 5;


  /* these constants are deprecated; use the corresponding */
  /* `FT_Render_Mode` values instead                       */
public static final int ft_render_mode_normal =  FT_RENDER_MODE_NORMAL;
public static final int ft_render_mode_mono =    FT_RENDER_MODE_MONO;


  /**************************************************************************
   *
   * \function:
   *   FT_Render_Glyph
   *
   * \description:
   *   Convert a given glyph image to a bitmap.  It does so by inspecting the
   *   glyph image format, finding the relevant renderer, and invoking it.
   *
   * \inout:
   *   slot ::
   *     A handle to the glyph slot containing the image to convert.
   *
   * \input:
   *   render_mode ::
   *     The render mode used to render the glyph image into a bitmap.  See
   *     \FT_Render_Mode for a list of possible values.
   *
   *     If \FT_RENDER_MODE_NORMAL is used, a previous call of \FT_Load_Glyph
   *     with flag \FT_LOAD_COLOR makes FT_Render_Glyph provide a default
   *     blending of colored glyph layers associated with the current glyph
   *     slot (provided the font contains such layers) instead of rendering
   *     the glyph slot's outline.  This is an experimental feature; see
   *     \FT_LOAD_COLOR for more information.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   To get meaningful results, font scaling values must be set with
   *   functions like \FT_Set_Char_Size before calling {@code FT_Render_Glyph}.
   *
   *   When FreeType outputs a bitmap of a glyph, it really outputs an alpha
   *   coverage map.  If a pixel is completely covered by a filled-in
   *   outline, the bitmap contains 0xFF at that pixel, meaning that
   *   0xFF/0xFF fraction of that pixel is covered, meaning the pixel is 100%
   *   black (or 0% bright).  If a pixel is only 50% covered (value 0x80),
   *   the pixel is made 50% black (50% bright or a middle shade of grey).
   *   0% covered means 0% black (100% bright or white).
   *
   *   On high-DPI screens like on smartphones and tablets, the pixels are so
   *   small that their chance of being completely covered and therefore
   *   completely black are fairly good.  On the low-DPI screens, however,
   *   the situation is different.  The pixels are too large for most of the
   *   details of a glyph and shades of gray are the norm rather than the
   *   exception.
   *
   *   This is relevant because all our screens have a second problem: they
   *   are not linear.  1~+~1 is not~2.  Twice the value does not result in
   *   twice the brightness.  When a pixel is only 50% covered, the coverage
   *   map says 50% black, and this translates to a pixel value of 128 when
   *   you use 8~bits per channel (0-255).  However, this does not translate
   *   to 50% brightness for that pixel on our sRGB and gamma~2.2 screens.
   *   Due to their non-linearity, they dwell longer in the darks and only a
   *   pixel value of about 186 results in 50% brightness -- 128 ends up too
   *   dark on both bright and dark backgrounds.  The net result is that dark
   *   text looks burnt-out, pixely and blotchy on bright background, bright
   *   text too frail on dark backgrounds, and colored text on colored
   *   background (for example, red on green) seems to have dark halos or
   *   'dirt' around it.  The situation is especially ugly for diagonal stems
   *   like in 'w' glyph shapes where the quality of FreeType's anti-aliasing
   *   depends on the correct display of grays.  On high-DPI screens where
   *   smaller, fully black pixels reign supreme, this doesn't matter, but on
   *   our low-DPI screens with all the gray shades, it does.  0% and 100%
   *   brightness are the same things in linear and non-linear space, just
   *   all the shades in-between aren't.
   *
   *   The blending function for placing text over a background is
   *
   *   <pre>{@code
   *     dst = alpha * src + (1 - alpha) * dst    ,
   *   }</pre>
   *
   *   which is known as the OVER operator.
   *
   *   To correctly composite an antialiased pixel of a glyph onto a surface,
   *
   *   1. take the foreground and background colors (e.g., in sRGB space)
   *      and apply gamma to get them in a linear space,
   *
   *   2. use OVER to blend the two linear colors using the glyph pixel
   *      as the alpha value (remember, the glyph bitmap is an alpha coverage
   *      bitmap), and
   *
   *   3. apply inverse gamma to the blended pixel and write it back to
   *      the image.
   *
   *   Internal testing at Adobe found that a target inverse gamma of~1.8 for
   *   step~3 gives good results across a wide range of displays with an sRGB
   *   gamma curve or a similar one.
   *
   *   This process can cost performance.  There is an approximation that
   *   does not need to know about the background color; see
   *   https://bel.fi/alankila/lcd/ and
   *   https://bel.fi/alankila/lcd/alpcor.html for details.
   *
   *   **ATTENTION**: Linear blending is even more important when dealing
   *   with subpixel-rendered glyphs to prevent color-fringing!  A
   *   subpixel-rendered glyph must first be filtered with a filter that
   *   gives equal weight to the three color primaries and does not exceed a
   *   sum of 0x100, see section \lcd_rendering.  Then the only difference to
   *   gray linear blending is that subpixel-rendered linear blending is done
   *   3~times per pixel: red foreground subpixel to red background subpixel
   *   and so on for green and blue.
   */
  


  /**************************************************************************
   *
   * \enum:
   *   FT_Kerning_Mode
   *
   * \description:
   *   An enumeration to specify the format of kerning values returned by
   *   \FT_Get_Kerning.
   *
   * \values:
   *   FT_KERNING_DEFAULT ::
   *     Return grid-fitted kerning distances in 26.6 fractional pixels.
   *
   *   FT_KERNING_UNFITTED ::
   *     Return un-grid-fitted kerning distances in 26.6 fractional pixels.
   *
   *   FT_KERNING_UNSCALED ::
   *     Return the kerning vector in original font units.
   *
   * \note:
   *   {@code FT_KERNING_DEFAULT} returns full pixel values; it also makes FreeType
   *   heuristically scale down kerning distances at small ppem values so
   *   that they don't become too big.
   *
   *   Both {@code FT_KERNING_DEFAULT} and {@code FT_KERNING_UNFITTED} use the current
   *   horizontal scaling factor (as set e.g. with \FT_Set_Char_Size) to
   *   convert font units to pixels.
   */
  /** enum FT_Kerning_Mode_ */
  public static final int
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED = 1,
    FT_KERNING_UNSCALED = 2;


  /* these constants are deprecated; use the corresponding */
  /* `FT_Kerning_Mode` values instead                      */
public static final int ft_kerning_default =   FT_KERNING_DEFAULT;
public static final int ft_kerning_unfitted =  FT_KERNING_UNFITTED;
public static final int ft_kerning_unscaled =  FT_KERNING_UNSCALED;


  /**************************************************************************
   *
   * \function:
   *   FT_Get_Kerning
   *
   * \description:
   *   Return the kerning vector between two glyphs of the same face.
   *
   * \input:
   *   face ::
   *     A handle to a source face object.
   *
   *   left_glyph ::
   *     The index of the left glyph in the kern pair.
   *
   *   right_glyph ::
   *     The index of the right glyph in the kern pair.
   *
   *   kern_mode ::
   *     See \FT_Kerning_Mode for more information.  Determines the scale and
   *     dimension of the returned kerning vector.
   *
   * \output:
   *   akerning ::
   *     The kerning vector.  This is either in font units, fractional pixels
   *     (26.6 format), or pixels for scalable formats, and in pixels for
   *     fixed-sizes formats.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   Only horizontal layouts (left-to-right & right-to-left) are supported
   *   by this method.  Other layouts, or more sophisticated kernings, are
   *   out of the scope of this API function -- they can be implemented
   *   through format-specific interfaces.
   *
   *   Kerning for OpenType fonts implemented in a 'GPOS' table is not
   *   supported; use \FT_HAS_KERNING to find out whether a font has data
   *   that can be extracted with {@code FT_Get_Kerning}.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Get_Track_Kerning
   *
   * \description:
   *   Return the track kerning for a given face object at a given size.
   *
   * \input:
   *   face ::
   *     A handle to a source face object.
   *
   *   point_size ::
   *     The point size in 16.16 fractional points.
   *
   *   degree ::
   *     The degree of tightness.  Increasingly negative values represent
   *     tighter track kerning, while increasingly positive values represent
   *     looser track kerning.  Value zero means no track kerning.
   *
   * \output:
   *   akerning ::
   *     The kerning in 16.16 fractional points, to be uniformly applied
   *     between all glyphs.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   Currently, only the Type~1 font driver supports track kerning, using
   *   data from AFM files (if attached with \FT_Attach_File or
   *   \FT_Attach_Stream).
   *
   *   Only very few AFM files come with track kerning data; please refer to
   *   Adobe's AFM specification for more details.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Get_Glyph_Name
   *
   * \description:
   *   Retrieve the ASCII name of a given glyph in a face.  This only works
   *   for those faces where \FT_HAS_GLYPH_NAMES(face) returns~1.
   *
   * \input:
   *   face ::
   *     A handle to a source face object.
   *
   *   glyph_index ::
   *     The glyph index.
   *
   *   buffer_max ::
   *     The maximum number of bytes available in the buffer.
   *
   * \output:
   *   buffer ::
   *     A pointer to a target buffer where the name is copied to.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   An error is returned if the face doesn't provide glyph names or if the
   *   glyph index is invalid.  In all cases of failure, the first byte of
   *   {@code buffer} is set to~0 to indicate an empty name.
   *
   *   The glyph name is truncated to fit within the buffer if it is too
   *   long.  The returned string is always zero-terminated.
   *
   *   Be aware that FreeType reorders glyph indices internally so that glyph
   *   index~0 always corresponds to the 'missing glyph' (called '.notdef').
   *
   *   This function always returns an error if the config macro
   *   {@code FT_CONFIG_OPTION_NO_GLYPH_NAMES} is not defined in {@code ftoption.h}.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Get_Postscript_Name
   *
   * \description:
   *   Retrieve the ASCII PostScript name of a given face, if available.
   *   This only works with PostScript, TrueType, and OpenType fonts.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   * @return :
   *   A pointer to the face's PostScript name.  {@code NULL} if unavailable.
   *
   * \note:
   *   The returned pointer is owned by the face and is destroyed with it.
   *
   *   For variation fonts, this string changes if you select a different
   *   instance, and you have to call {@code FT_Get_PostScript_Name} again to
   *   retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating
   *   PostScript Names for Fonts Using OpenType Font Variations'.
   *
   *     https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html
   *
   *   [Since 2.9] Special PostScript names for named instances are only
   *   returned if the named instance is set with \FT_Set_Named_Instance (and
   *   the font has corresponding entries in its 'fvar' table).  If
   *   \FT_IS_VARIATION returns true, the algorithmically derived PostScript
   *   name is provided, not looking up special entries for named instances.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Select_Charmap
   *
   * \description:
   *   Select a given charmap by its encoding tag (as listed in
   *   {@code freetype.h}).
   *
   * \inout:
   *   face ::
   *     A handle to the source face object.
   *
   * \input:
   *   encoding ::
   *     A handle to the selected encoding.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   This function returns an error if no charmap in the face corresponds
   *   to the encoding queried here.
   *
   *   Because many fonts contain more than a single cmap for Unicode
   *   encoding, this function has some special code to select the one that
   *   covers Unicode best ('best' in the sense that a UCS-4 cmap is
   *   preferred to a UCS-2 cmap).  It is thus preferable to \FT_Set_Charmap
   *   in this case.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Set_Charmap
   *
   * \description:
   *   Select a given charmap for character code to glyph index mapping.
   *
   * \inout:
   *   face ::
   *     A handle to the source face object.
   *
   * \input:
   *   charmap ::
   *     A handle to the selected charmap.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   This function returns an error if the charmap is not part of the face
   *   (i.e., if it is not listed in the {@code face->charmaps} table).
   *
   *   It also fails if an OpenType type~14 charmap is selected (which
   *   doesn't map character codes to glyph indices at all).
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Get_Charmap_Index
   *
   * \description:
   *   Retrieve index of a given charmap.
   *
   * \input:
   *   charmap ::
   *     A handle to a charmap.
   *
   * @return :
   *   The index into the array of character maps within the face to which
   *   {@code charmap} belongs.  If an error occurs, -1 is returned.
   *
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Get_Char_Index
   *
   * \description:
   *   Return the glyph index of a given character code.  This function uses
   *   the currently selected charmap to do the mapping.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   *   charcode ::
   *     The character code.
   *
   * @return :
   *   The glyph index.  0~means 'undefined character code'.
   *
   * \note:
   *   If you use FreeType to manipulate the contents of font files directly,
   *   be aware that the glyph index returned by this function doesn't always
   *   correspond to the internal indices used within the file.  This is done
   *   to ensure that value~0 always corresponds to the 'missing glyph'.  If
   *   the first glyph is not named '.notdef', then for Type~1 and Type~42
   *   fonts, '.notdef' will be moved into the glyph ID~0 position, and
   *   whatever was there will be moved to the position '.notdef' had.  For
   *   Type~1 fonts, if there is no '.notdef' glyph at all, then one will be
   *   created at index~0 and whatever was there will be moved to the last
   *   index -- Type~42 fonts are considered invalid under this condition.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Get_First_Char
   *
   * \description:
   *   Return the first character code in the current charmap of a given
   *   face, together with its corresponding glyph index.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   * \output:
   *   agindex ::
   *     Glyph index of first character code.  0~if charmap is empty.
   *
   * @return :
   *   The charmap's first character code.
   *
   * \note:
   *   You should use this function together with \FT_Get_Next_Char to parse
   *   all character codes available in a given charmap.  The code should
   *   look like this:
   *
   *   <pre>{@code
   *     FT_ULong  charcode;
   *     FT_UInt   gindex;
   *
   *
   *     charcode = FT_Get_First_Char( face, &gindex );
   *     while ( gindex != 0 )
   *     {
   *       ... do something with (charcode,gindex) pair ...
   *
   *       charcode = FT_Get_Next_Char( face, charcode, &gindex );
   *     }
   *   }</pre>
   *
   *   Be aware that character codes can have values up to 0xFFFFFFFF; this
   *   might happen for non-Unicode or malformed cmaps.  However, even with
   *   regular Unicode encoding, so-called 'last resort fonts' (using SFNT
   *   cmap format 13, see function \FT_Get_CMap_Format) normally have
   *   entries for all Unicode characters up to 0x1FFFFF, which can cause *a
   *   lot* of iterations.
   *
   *   Note that {@code *agindex} is set to~0 if the charmap is empty.  The result
   *   itself can be~0 in two cases: if the charmap is empty or if the
   *   value~0 is the first valid character code.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Get_Next_Char
   *
   * \description:
   *   Return the next character code in the current charmap of a given face
   *   following the value {@code char_code}, as well as the corresponding glyph
   *   index.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   *   char_code ::
   *     The starting character code.
   *
   * \output:
   *   agindex ::
   *     Glyph index of next character code.  0~if charmap is empty.
   *
   * @return :
   *   The charmap's next character code.
   *
   * \note:
   *   You should use this function with \FT_Get_First_Char to walk over all
   *   character codes available in a given charmap.  See the note for that
   *   function for a simple code example.
   *
   *   Note that {@code *agindex} is set to~0 when there are no more codes in the
   *   charmap.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Face_Properties
   *
   * \description:
   *   Set or override certain (library or module-wide) properties on a
   *   face-by-face basis.  Useful for finer-grained control and avoiding
   *   locks on shared structures (threads can modify their own faces as they
   *   see fit).
   *
   *   Contrary to \FT_Property_Set, this function uses \FT_Parameter so that
   *   you can pass multiple properties to the target face in one call.  Note
   *   that only a subset of the available properties can be controlled.
   *
   *   * \FT_PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the
   *     property {@code no-stem-darkening} provided by the 'autofit', 'cff',
   *     'type1', and 't1cid' modules; see \no-stem-darkening).
   *
   *   * \FT_PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding
   *     to function \FT_Library_SetLcdFilterWeights).
   *
   *   * \FT_PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID
   *     'random' operator, corresponding to the {@code random-seed} property
   *     provided by the 'cff', 'type1', and 't1cid' modules; see
   *     \random-seed).
   *
   *   Pass {@code NULL} as {@code data} in \FT_Parameter for a given tag to reset the
   *   option and use the library or module default again.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   *   num_properties ::
   *     The number of properties that follow.
   *
   *   properties ::
   *     A handle to an \FT_Parameter array with {@code num_properties} elements.
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \example:
   *   Here is an example that sets three properties.  You must define
   *   {@code FT_CONFIG_OPTION_SUBPIXEL_RENDERING} to make the LCD filter examples
   *   work.
   *
   *   <pre>{@code
   *     FT_Parameter         property1;
   *     FT_Bool              darken_stems = 1;
   *
   *     FT_Parameter         property2;
   *     FT_LcdFiveTapFilter  custom_weight =
   *                            { 0x11, 0x44, 0x56, 0x44, 0x11 };
   *
   *     FT_Parameter         property3;
   *     FT_Int32             random_seed = 314159265;
   *
   *     FT_Parameter         properties[3] = { property1,
   *                                            property2,
   *                                            property3 };
   *
   *
   *     property1.tag  = FT_PARAM_TAG_STEM_DARKENING;
   *     property1.data = &darken_stems;
   *
   *     property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
   *     property2.data = custom_weight;
   *
   *     property3.tag  = FT_PARAM_TAG_RANDOM_SEED;
   *     property3.data = &random_seed;
   *
   *     FT_Face_Properties( face, 3, properties );
   *   }</pre>
   *
   *   The next example resets a single property to its default value.
   *
   *   <pre>{@code
   *     FT_Parameter  property;
   *
   *
   *     property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;
   *     property.data = NULL;
   *
   *     FT_Face_Properties( face, 1, &property );
   *   }</pre>
   *
   * @since :
   *   2.8
   *
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Get_Name_Index
   *
   * \description:
   *   Return the glyph index of a given glyph name.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   *   glyph_name ::
   *     The glyph name.
   *
   * @return :
   *   The glyph index.  0~means 'undefined character code'.
   */
  


  /**************************************************************************
   *
   * \enum:
   *   FT_SUBGLYPH_FLAG_XXX
   *
   * \description:
   *   A list of constants describing subglyphs.  Please refer to the 'glyf'
   *   table description in the OpenType specification for the meaning of the
   *   various flags (which get synthesized for non-OpenType subglyphs).
   *
   *     https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description
   *
   * \values:
   *   FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS ::
   *   FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES ::
   *   FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID ::
   *   FT_SUBGLYPH_FLAG_SCALE ::
   *   FT_SUBGLYPH_FLAG_XY_SCALE ::
   *   FT_SUBGLYPH_FLAG_2X2 ::
   *   FT_SUBGLYPH_FLAG_USE_MY_METRICS ::
   *
   */
public static final int FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS =          1;
public static final int FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES =      2;
public static final int FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID =        4;
public static final int FT_SUBGLYPH_FLAG_SCALE =                   8;
public static final int FT_SUBGLYPH_FLAG_XY_SCALE =             0x40;
public static final int FT_SUBGLYPH_FLAG_2X2 =                  0x80;
public static final int FT_SUBGLYPH_FLAG_USE_MY_METRICS =      0x200;


  /**************************************************************************
   *
   * \function:
   *   FT_Get_SubGlyph_Info
   *
   * \description:
   *   Retrieve a description of a given subglyph.  Only use it if
   *   {@code glyph->format} is \FT_GLYPH_FORMAT_COMPOSITE; an error is returned
   *   otherwise.
   *
   * \input:
   *   glyph ::
   *     The source glyph slot.
   *
   *   sub_index ::
   *     The index of the subglyph.  Must be less than
   *     {@code glyph->num_subglyphs}.
   *
   * \output:
   *   p_index ::
   *     The glyph index of the subglyph.
   *
   *   p_flags ::
   *     The subglyph flags, see \FT_SUBGLYPH_FLAG_XXX.
   *
   *   p_arg1 ::
   *     The subglyph's first argument (if any).
   *
   *   p_arg2 ::
   *     The subglyph's second argument (if any).
   *
   *   p_transform ::
   *     The subglyph transformation (if any).
   *
   * @return :
   *   FreeType error code.  0~means success.
   *
   * \note:
   *   The values of {@code *p_arg1}, {@code *p_arg2}, and {@code *p_transform} must be
   *   interpreted depending on the flags returned in {@code *p_flags}.  See the
   *   OpenType specification for details.
   *
   *     https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description
   *
   */
  
// Targeting ../FT_LayerIterator.java




  /**************************************************************************
   *
   * \function:
   *   FT_Get_Color_Glyph_Layer
   *
   * \description:
   *   This is an interface to the 'COLR' table in OpenType fonts to
   *   iteratively retrieve the colored glyph layers associated with the
   *   current glyph slot.
   *
   *     https://docs.microsoft.com/en-us/typography/opentype/spec/colr
   *
   *   The glyph layer data for a given glyph index, if present, provides an
   *   alternative, multi-colour glyph representation: Instead of rendering
   *   the outline or bitmap with the given glyph index, glyphs with the
   *   indices and colors returned by this function are rendered layer by
   *   layer.
   *
   *   The returned elements are ordered in the z~direction from bottom to
   *   top; the 'n'th element should be rendered with the associated palette
   *   color and blended on top of the already rendered layers (elements 0,
   *   1, ..., n-1).
   *
   * \input:
   *   face ::
   *     A handle to the parent face object.
   *
   *   base_glyph ::
   *     The glyph index the colored glyph layers are associated with.
   *
   * \inout:
   *   iterator ::
   *     An \FT_LayerIterator object.  For the first call you should set
   *     {@code iterator->p} to {@code NULL}.  For all following calls, simply use the
   *     same object again.
   *
   * \output:
   *   aglyph_index ::
   *     The glyph index of the current layer.
   *
   *   acolor_index ::
   *     The color index into the font face's color palette of the current
   *     layer.  The value 0xFFFF is special; it doesn't reference a palette
   *     entry but indicates that the text foreground color should be used
   *     instead (to be set up by the application outside of FreeType).
   *
   *     The color palette can be retrieved with \FT_Palette_Select.
   *
   * @return :
   *   Value~1 if everything is OK.  If there are no more layers (or if there
   *   are no layers at all), value~0 gets returned.  In case of an error,
   *   value~0 is returned also.
   *
   * \note:
   *   This function is necessary if you want to handle glyph layers by
   *   yourself.  In particular, functions that operate with \FT_GlyphRec
   *   objects (like \FT_Get_Glyph or \FT_Glyph_To_Bitmap) don't have access
   *   to this information.
   *
   *   Note that \FT_Render_Glyph is able to handle colored glyph layers
   *   automatically if the \FT_LOAD_COLOR flag is passed to a previous call
   *   to \FT_Load_Glyph.  [This is an experimental feature.]
   *
   * \example:
   *   <pre>{@code
   *     FT_Color*         palette;
   *     FT_LayerIterator  iterator;
   *
   *     FT_Bool  have_layers;
   *     FT_UInt  layer_glyph_index;
   *     FT_UInt  layer_color_index;
   *
   *
   *     error = FT_Palette_Select( face, palette_index, &palette );
   *     if ( error )
   *       palette = NULL;
   *
   *     iterator.p  = NULL;
   *     have_layers = FT_Get_Color_Glyph_Layer( face,
   *                                             glyph_index,
   *                                             &layer_glyph_index,
   *                                             &layer_color_index,
   *                                             &iterator );
   *
   *     if ( palette && have_layers )
   *     {
   *       do
   *       {
   *         FT_Color  layer_color;
   *
   *
   *         if ( layer_color_index == 0xFFFF )
   *           layer_color = text_foreground_color;
   *         else
   *           layer_color = palette[layer_color_index];
   *
   *         // Load and render glyph `layer_glyph_index', then
   *         // blend resulting pixmap (using color `layer_color')
   *         // with previously created pixmaps.
   *
   *       } while ( FT_Get_Color_Glyph_Layer( face,
   *                                           glyph_index,
   *                                           &layer_glyph_index,
   *                                           &layer_color_index,
   *                                           &iterator ) );
   *     }
   *   }</pre>
   */
  


  /**************************************************************************
   *
   * \section:
   *   base_interface
   *
   */

  /**************************************************************************
   *
   * \enum:
   *   FT_FSTYPE_XXX
   *
   * \description:
   *   A list of bit flags used in the {@code fsType} field of the OS/2 table in a
   *   TrueType or OpenType font and the {@code FSType} entry in a PostScript font.
   *   These bit flags are returned by \FT_Get_FSType_Flags; they inform
   *   client applications of embedding and subsetting restrictions
   *   associated with a font.
   *
   *   See
   *   https://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/FontPolicies.pdf
   *   for more details.
   *
   * \values:
   *   FT_FSTYPE_INSTALLABLE_EMBEDDING ::
   *     Fonts with no fsType bit set may be embedded and permanently
   *     installed on the remote system by an application.
   *
   *   FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING ::
   *     Fonts that have only this bit set must not be modified, embedded or
   *     exchanged in any manner without first obtaining permission of the
   *     font software copyright owner.
   *
   *   FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING ::
   *     The font may be embedded and temporarily loaded on the remote
   *     system.  Documents containing Preview & Print fonts must be opened
   *     'read-only'; no edits can be applied to the document.
   *
   *   FT_FSTYPE_EDITABLE_EMBEDDING ::
   *     The font may be embedded but must only be installed temporarily on
   *     other systems.  In contrast to Preview & Print fonts, documents
   *     containing editable fonts may be opened for reading, editing is
   *     permitted, and changes may be saved.
   *
   *   FT_FSTYPE_NO_SUBSETTING ::
   *     The font may not be subsetted prior to embedding.
   *
   *   FT_FSTYPE_BITMAP_EMBEDDING_ONLY ::
   *     Only bitmaps contained in the font may be embedded; no outline data
   *     may be embedded.  If there are no bitmaps available in the font,
   *     then the font is unembeddable.
   *
   * \note:
   *   The flags are ORed together, thus more than a single value can be
   *   returned.
   *
   *   While the {@code fsType} flags can indicate that a font may be embedded, a
   *   license with the font vendor may be separately required to use the
   *   font in this way.
   */
public static final int FT_FSTYPE_INSTALLABLE_EMBEDDING =         0x0000;
public static final int FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING =  0x0002;
public static final int FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING =   0x0004;
public static final int FT_FSTYPE_EDITABLE_EMBEDDING =            0x0008;
public static final int FT_FSTYPE_NO_SUBSETTING =                 0x0100;
public static final int FT_FSTYPE_BITMAP_EMBEDDING_ONLY =         0x0200;


  /**************************************************************************
   *
   * \function:
   *   FT_Get_FSType_Flags
   *
   * \description:
   *   Return the {@code fsType} flags for a font.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   * @return :
   *   The {@code fsType} flags, see \FT_FSTYPE_XXX.
   *
   * \note:
   *   Use this function rather than directly reading the {@code fs_type} field in
   *   the \PS_FontInfoRec structure, which is only guaranteed to return the
   *   correct results for Type~1 fonts.
   *
   * @since :
   *   2.3.8
   */
  


  /**************************************************************************
   *
   * \section:
   *   glyph_variants
   *
   * \title:
   *   Unicode Variation Sequences
   *
   * \abstract:
   *   The FreeType~2 interface to Unicode Variation Sequences (UVS), using
   *   the SFNT cmap format~14.
   *
   * \description:
   *   Many characters, especially for CJK scripts, have variant forms.  They
   *   are a sort of grey area somewhere between being totally irrelevant and
   *   semantically distinct; for this reason, the Unicode consortium decided
   *   to introduce Variation Sequences (VS), consisting of a Unicode base
   *   character and a variation selector instead of further extending the
   *   already huge number of characters.
   *
   *   Unicode maintains two different sets, namely 'Standardized Variation
   *   Sequences' and registered 'Ideographic Variation Sequences' (IVS),
   *   collected in the 'Ideographic Variation Database' (IVD).
   *
   *     https://unicode.org/Public/UCD/latest/ucd/StandardizedVariants.txt
   *     https://unicode.org/reports/tr37/ https://unicode.org/ivd/
   *
   *   To date (January 2017), the character with the most ideographic
   *   variations is U+9089, having 32 such IVS.
   *
   *   Three Mongolian Variation Selectors have the values U+180B-U+180D; 256
   *   generic Variation Selectors are encoded in the ranges U+FE00-U+FE0F
   *   and U+E0100-U+E01EF.  IVS currently use Variation Selectors from the
   *   range U+E0100-U+E01EF only.
   *
   *   A VS consists of the base character value followed by a single
   *   Variation Selector.  For example, to get the first variation of
   *   U+9089, you have to write the character sequence {@code U+9089 U+E0100}.
   *
   *   Adobe and MS decided to support both standardized and ideographic VS
   *   with a new cmap subtable (format~14).  It is an odd subtable because
   *   it is not a mapping of input code points to glyphs, but contains lists
   *   of all variations supported by the font.
   *
   *   A variation may be either 'default' or 'non-default' for a given font.
   *   A default variation is the one you will get for that code point if you
   *   look it up in the standard Unicode cmap.  A non-default variation is a
   *   different glyph.
   *
   */


  /**************************************************************************
   *
   * \function:
   *   FT_Face_GetCharVariantIndex
   *
   * \description:
   *   Return the glyph index of a given character code as modified by the
   *   variation selector.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   *   charcode ::
   *     The character code point in Unicode.
   *
   *   variantSelector ::
   *     The Unicode code point of the variation selector.
   *
   * @return :
   *   The glyph index.  0~means either 'undefined character code', or
   *   'undefined selector code', or 'no variation selector cmap subtable',
   *   or 'current CharMap is not Unicode'.
   *
   * \note:
   *   If you use FreeType to manipulate the contents of font files directly,
   *   be aware that the glyph index returned by this function doesn't always
   *   correspond to the internal indices used within the file.  This is done
   *   to ensure that value~0 always corresponds to the 'missing glyph'.
   *
   *   This function is only meaningful if
   *     a) the font has a variation selector cmap sub table, and
   *     b) the current charmap has a Unicode encoding.
   *
   * @since :
   *   2.3.6
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Face_GetCharVariantIsDefault
   *
   * \description:
   *   Check whether this variation of this Unicode character is the one to
   *   be found in the charmap.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   *   charcode ::
   *     The character codepoint in Unicode.
   *
   *   variantSelector ::
   *     The Unicode codepoint of the variation selector.
   *
   * @return :
   *   1~if found in the standard (Unicode) cmap, 0~if found in the variation
   *   selector cmap, or -1 if it is not a variation.
   *
   * \note:
   *   This function is only meaningful if the font has a variation selector
   *   cmap subtable.
   *
   * @since :
   *   2.3.6
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Face_GetVariantSelectors
   *
   * \description:
   *   Return a zero-terminated list of Unicode variation selectors found in
   *   the font.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   * @return :
   *   A pointer to an array of selector code points, or {@code NULL} if there is
   *   no valid variation selector cmap subtable.
   *
   * \note:
   *   The last item in the array is~0; the array is owned by the \FT_Face
   *   object but can be overwritten or released on the next call to a
   *   FreeType function.
   *
   * @since :
   *   2.3.6
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Face_GetVariantsOfChar
   *
   * \description:
   *   Return a zero-terminated list of Unicode variation selectors found for
   *   the specified character code.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   *   charcode ::
   *     The character codepoint in Unicode.
   *
   * @return :
   *   A pointer to an array of variation selector code points that are
   *   active for the given character, or {@code NULL} if the corresponding list is
   *   empty.
   *
   * \note:
   *   The last item in the array is~0; the array is owned by the \FT_Face
   *   object but can be overwritten or released on the next call to a
   *   FreeType function.
   *
   * @since :
   *   2.3.6
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Face_GetCharsOfVariant
   *
   * \description:
   *   Return a zero-terminated list of Unicode character codes found for the
   *   specified variation selector.
   *
   * \input:
   *   face ::
   *     A handle to the source face object.
   *
   *   variantSelector ::
   *     The variation selector code point in Unicode.
   *
   * @return :
   *   A list of all the code points that are specified by this selector
   *   (both default and non-default codes are returned) or {@code NULL} if there
   *   is no valid cmap or the variation selector is invalid.
   *
   * \note:
   *   The last item in the array is~0; the array is owned by the \FT_Face
   *   object but can be overwritten or released on the next call to a
   *   FreeType function.
   *
   * @since :
   *   2.3.6
   */
  


  /**************************************************************************
   *
   * \section:
   *   computations
   *
   * \title:
   *   Computations
   *
   * \abstract:
   *   Crunching fixed numbers and vectors.
   *
   * \description:
   *   This section contains various functions used to perform computations
   *   on 16.16 fixed-float numbers or 2d vectors.
   *
   *   **Attention**: Most arithmetic functions take {@code FT_Long} as arguments.
   *   For historical reasons, FreeType was designed under the assumption
   *   that {@code FT_Long} is a 32-bit integer; results can thus be undefined if
   *   the arguments don't fit into 32 bits.
   *
   * \order:
   *   FT_MulDiv
   *   FT_MulFix
   *   FT_DivFix
   *   FT_RoundFix
   *   FT_CeilFix
   *   FT_FloorFix
   *   FT_Vector_Transform
   *   FT_Matrix_Multiply
   *   FT_Matrix_Invert
   *
   */


  /**************************************************************************
   *
   * \function:
   *   FT_MulDiv
   *
   * \description:
   *   Compute {@code (a*b)/c} with maximum accuracy, using a 64-bit intermediate
   *   integer whenever necessary.
   *
   *   This function isn't necessarily as fast as some processor-specific
   *   operations, but is at least completely portable.
   *
   * \input:
   *   a ::
   *     The first multiplier.
   *
   *   b ::
   *     The second multiplier.
   *
   *   c ::
   *     The divisor.
   *
   * @return :
   *   The result of {@code (a*b)/c}.  This function never traps when trying to
   *   divide by zero; it simply returns 'MaxInt' or 'MinInt' depending on
   *   the signs of {@code a} and {@code b}.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_MulFix
   *
   * \description:
   *   Compute {@code (a*b)/0x10000} with maximum accuracy.  Its main use is to
   *   multiply a given value by a 16.16 fixed-point factor.
   *
   * \input:
   *   a ::
   *     The first multiplier.
   *
   *   b ::
   *     The second multiplier.  Use a 16.16 factor here whenever possible
   *     (see note below).
   *
   * @return :
   *   The result of {@code (a*b)/0x10000}.
   *
   * \note:
   *   This function has been optimized for the case where the absolute value
   *   of {@code a} is less than 2048, and {@code b} is a 16.16 scaling factor.  As this
   *   happens mainly when scaling from notional units to fractional pixels
   *   in FreeType, it resulted in noticeable speed improvements between
   *   versions 2.x and 1.x.
   *
   *   As a conclusion, always try to place a 16.16 factor as the _second_
   *   argument of this function; this can make a great difference.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_DivFix
   *
   * \description:
   *   Compute {@code (a*0x10000)/b} with maximum accuracy.  Its main use is to
   *   divide a given value by a 16.16 fixed-point factor.
   *
   * \input:
   *   a ::
   *     The numerator.
   *
   *   b ::
   *     The denominator.  Use a 16.16 factor here.
   *
   * @return :
   *   The result of {@code (a*0x10000)/b}.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_RoundFix
   *
   * \description:
   *   Round a 16.16 fixed number.
   *
   * \input:
   *   a ::
   *     The number to be rounded.
   *
   * @return :
   *   {@code a} rounded to the nearest 16.16 fixed integer, halfway cases away
   *   from zero.
   *
   * \note:
   *   The function uses wrap-around arithmetic.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_CeilFix
   *
   * \description:
   *   Compute the smallest following integer of a 16.16 fixed number.
   *
   * \input:
   *   a ::
   *     The number for which the ceiling function is to be computed.
   *
   * @return :
   *   {@code a} rounded towards plus infinity.
   *
   * \note:
   *   The function uses wrap-around arithmetic.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_FloorFix
   *
   * \description:
   *   Compute the largest previous integer of a 16.16 fixed number.
   *
   * \input:
   *   a ::
   *     The number for which the floor function is to be computed.
   *
   * @return :
   *   {@code a} rounded towards minus infinity.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Vector_Transform
   *
   * \description:
   *   Transform a single vector through a 2x2 matrix.
   *
   * \inout:
   *   vector ::
   *     The target vector to transform.
   *
   * \input:
   *   matrix ::
   *     A pointer to the source 2x2 matrix.
   *
   * \note:
   *   The result is undefined if either {@code vector} or {@code matrix} is invalid.
   */
  


  /**************************************************************************
   *
   * \section:
   *   version
   *
   * \title:
   *   FreeType Version
   *
   * \abstract:
   *   Functions and macros related to FreeType versions.
   *
   * \description:
   *   Note that those functions and macros are of limited use because even a
   *   new release of FreeType with only documentation changes increases the
   *   version number.
   *
   * \order:
   *   FT_Library_Version
   *
   *   FREETYPE_MAJOR
   *   FREETYPE_MINOR
   *   FREETYPE_PATCH
   *
   *   FT_Face_CheckTrueTypePatents
   *   FT_Face_SetUnpatentedHinting
   *
   */


  /**************************************************************************
   *
   * \enum:
   *   FREETYPE_XXX
   *
   * \description:
   *   These three macros identify the FreeType source code version.  Use
   *   \FT_Library_Version to access them at runtime.
   *
   * \values:
   *   FREETYPE_MAJOR ::
   *     The major version number.
   *   FREETYPE_MINOR ::
   *     The minor version number.
   *   FREETYPE_PATCH ::
   *     The patch level.
   *
   * \note:
   *   The version number of FreeType if built as a dynamic link library with
   *   the 'libtool' package is _not_ controlled by these three macros.
   *
   */
public static final int FREETYPE_MAJOR =  2;
public static final int FREETYPE_MINOR =  10;
public static final int FREETYPE_PATCH =  1;


  /**************************************************************************
   *
   * \function:
   *   FT_Library_Version
   *
   * \description:
   *   Return the version of the FreeType library being used.  This is useful
   *   when dynamically linking to the library, since one cannot use the
   *   macros \FREETYPE_MAJOR, \FREETYPE_MINOR, and \FREETYPE_PATCH.
   *
   * \input:
   *   library ::
   *     A source library handle.
   *
   * \output:
   *   amajor ::
   *     The major version number.
   *
   *   aminor ::
   *     The minor version number.
   *
   *   apatch ::
   *     The patch version number.
   *
   * \note:
   *   The reason why this function takes a {@code library} argument is because
   *   certain programs implement library initialization in a custom way that
   *   doesn't use \FT_Init_FreeType.
   *
   *   In such cases, the library version might not be available before the
   *   library object has been created.
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Face_CheckTrueTypePatents
   *
   * \description:
   *   Deprecated, does nothing.
   *
   * \input:
   *   face ::
   *     A face handle.
   *
   * @return :
   *   Always returns false.
   *
   * \note:
   *   Since May 2010, TrueType hinting is no longer patented.
   *
   * @since :
   *   2.3.5
   */
  


  /**************************************************************************
   *
   * \function:
   *   FT_Face_SetUnpatentedHinting
   *
   * \description:
   *   Deprecated, does nothing.
   *
   * \input:
   *   face ::
   *     A face handle.
   *
   *   value ::
   *     New boolean setting.
   *
   * @return :
   *   Always returns false.
   *
   * \note:
   *   Since May 2010, TrueType hinting is no longer patented.
   *
   * @since :
   *   2.3.5
   */
  

  /* */

// #endif /* FREETYPE_H_ */


/* END */




}
