// Targeted by JavaCPP version 1.5.2-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.freetype;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.freetype.global.freetype.*;



  /**************************************************************************
   *
   * \struct:
   *   FT_Open_Args
   *
   * \description:
   *   A structure to indicate how to open a new font file or stream.  A
   *   pointer to such a structure can be used as a parameter for the
   *   functions \FT_Open_Face and \FT_Attach_Stream.
   *
   * \fields:
   *   flags ::
   *     A set of bit flags indicating how to use the structure.
   *
   *   memory_base ::
   *     The first byte of the file in memory.
   *
   *   memory_size ::
   *     The size in bytes of the file in memory.
   *
   *   pathname ::
   *     A pointer to an 8-bit file pathname.
   *
   *   stream ::
   *     A handle to a source stream object.
   *
   *   driver ::
   *     This field is exclusively used by \FT_Open_Face; it simply specifies
   *     the font driver to use for opening the face.  If set to {@code NULL},
   *     FreeType tries to load the face with each one of the drivers in its
   *     list.
   *
   *   num_params ::
   *     The number of extra parameters.
   *
   *   params ::
   *     Extra parameters passed to the font driver when opening a new face.
   *
   * \note:
   *   The stream type is determined by the contents of {@code flags} that are
   *   tested in the following order by \FT_Open_Face:
   *
   *   If the \FT_OPEN_MEMORY bit is set, assume that this is a memory file
   *   of {@code memory_size} bytes, located at {@code memory_address}.  The data are not
   *   copied, and the client is responsible for releasing and destroying
   *   them _after_ the corresponding call to \FT_Done_Face.
   *
   *   Otherwise, if the \FT_OPEN_STREAM bit is set, assume that a custom
   *   input stream {@code stream} is used.
   *
   *   Otherwise, if the \FT_OPEN_PATHNAME bit is set, assume that this is a
   *   normal file and use {@code pathname} to open it.
   *
   *   If the \FT_OPEN_DRIVER bit is set, \FT_Open_Face only tries to open
   *   the file with the driver whose handler is in {@code driver}.
   *
   *   If the \FT_OPEN_PARAMS bit is set, the parameters given by
   *   {@code num_params} and {@code params} is used.  They are ignored otherwise.
   *
   *   Ideally, both the {@code pathname} and {@code params} fields should be tagged as
   *   'const'; this is missing for API backward compatibility.  In other
   *   words, applications should treat them as read-only.
   */
  @Properties(inherit = org.bytedeco.freetype.presets.freetype.class)
public class FT_Open_Args extends Pointer {
      static { Loader.load(); }
      /** Default native constructor. */
      public FT_Open_Args() { super((Pointer)null); allocate(); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public FT_Open_Args(long size) { super((Pointer)null); allocateArray(size); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public FT_Open_Args(Pointer p) { super(p); }
      private native void allocate();
      private native void allocateArray(long size);
      @Override public FT_Open_Args position(long position) {
          return (FT_Open_Args)super.position(position);
      }
  
    public native @Cast("FT_UInt") int flags(); public native FT_Open_Args flags(int setter);
    public native @Cast("const FT_Byte*") BytePointer memory_base(); public native FT_Open_Args memory_base(BytePointer setter);
    public native @Cast("FT_Long") long memory_size(); public native FT_Open_Args memory_size(long setter);
    public native @Cast("FT_String*") BytePointer pathname(); public native FT_Open_Args pathname(BytePointer setter);
    public native FT_Stream stream(); public native FT_Open_Args stream(FT_Stream setter);
    public native FT_Module driver(); public native FT_Open_Args driver(FT_Module setter);
    public native @Cast("FT_Int") int num_params(); public native FT_Open_Args num_params(int setter);
    public native FT_Parameter params(); public native FT_Open_Args params(FT_Parameter setter);

  }
