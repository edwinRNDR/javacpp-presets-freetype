// Targeted by JavaCPP version 1.5.2: DO NOT EDIT THIS FILE

package org.bytedeco.dnnl;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.dnnl.global.dnnl.*;


/** \}
 <p>
 *  \addtogroup cpp_api_memory_related Memory and memory related operations
 *  \{
 <p>
 *  \addtogroup cpp_api_memory Memory
 *  A primitive to describe and store data.
 * 
 *  For more information, refer to \ref c_api_memory in \ref c_api.
 *  \{
 <p>
 *  Memory that describes the data. */
@Namespace("dnnl") @Properties(inherit = org.bytedeco.dnnl.presets.dnnl.class)
public class memory extends dnnl_memory_handle {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public memory(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public memory(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public memory position(long position) {
        return (memory)super.position(position);
    }


    /** Data type specification */
    public enum data_type {
        /** Undefined data type, used for empty memory descriptors. */
        undef(dnnl_data_type_undef),
        /** 16-bit/half-precision floating point. */
        f16(dnnl_f16),
        /** non-standard 16-bit (bfloat16 w/ 7 bit mantissa) floating point. */
        bf16(dnnl_bf16),
        /** 32-bit/single-precision floating point. */
        f32(dnnl_f32),
        /** 32-bit signed integer. */
        s32(dnnl_s32),
        /** 8-bit signed integer. */
        s8(dnnl_s8),
        /** 8-bit unsigned integer. */
        u8(dnnl_u8);

        public final int value;
        private data_type(int v) { this.value = v; }
        private data_type(data_type e) { this.value = e.value; }
        public data_type intern() { for (data_type e : values()) if (e.value == value) return e; return this; }
        @Override public String toString() { return intern().name(); }
    }

    /** Memory format kind */
    public enum format_kind {
        /** Undefined memory format kind, used for empty memory descriptors. */
        undef(dnnl_format_kind_undef),
        /** Unspecified format kind.
         *  The primitive selects a format automatically. */
        any(dnnl_format_kind_any),
        /** A tensor in a generic format described by the stride and blocking
         *  values in each dimension. See \ref dnnl_blocking_desc_t for more
         *  information. */
        blocked(dnnl_blocked),
        /** Weights format used in 8bit Winograd convolution */
        wino(dnnl_format_kind_wino),
        /** Packed weights format used in RNN */
        packed(dnnl_format_kind_rnn_packed);

        public final int value;
        private format_kind(int v) { this.value = v; }
        private format_kind(format_kind e) { this.value = e.value; }
        public format_kind intern() { for (format_kind e : values()) if (e.value == value) return e; return this; }
        @Override public String toString() { return intern().name(); }
    }

    /** Memory format tag specification. See \ref dnnl_format_tag_t for a
     *  detailed description. */
    public enum format_tag {
        /** Undefined memory format tag */
        undef(dnnl_format_tag_undef),
        /** Placeholder memory format tag. The primitive selects a format
         *  automatically. */
        any(dnnl_format_tag_any),

        // Semantic agnostic section
        // The physical order of dimensions is defined by the permutation of the
        // characters, assuming that ab..z defines the natural order.

        // Plain formats

        /** plain 1D tensor */
        a(dnnl_a),
        /** plain 2D tensor */
        ab(dnnl_ab),
        /** plain 3D tensor */
        abc(dnnl_abc),
        /** plain 4D tensor */
        abcd(dnnl_abcd),
        /** plain 5D tensor */
        abcde(dnnl_abcde),
        /** plain 6D tensor */
        abcdef(dnnl_abcdef),

        // Permuted plain formats

        /** permuted 5D tensor */
        abdec(dnnl_abdec),
        /** permuted 3D tensor */
        acb(dnnl_acb),
        /** permuted 5D tensor */
        acbde(dnnl_acbde),
        /** permuted 4D tensor */
        acdb(dnnl_acdb),
        /** permuted 5D tensor */
        acdeb(dnnl_acdeb),
        /** permuted 2D tensor */
        ba(dnnl_ba),
        /** permuted 3D tensor */
        bac(dnnl_bac),
        /** permuted 4D tensor */
        bacd(dnnl_bacd),
        /** permuted 4D tensor */
        bcda(dnnl_bcda),
        /** permuted 3D tensor */
        cba(dnnl_cba),
        /** permuted 4D tensor */
        cdba(dnnl_cdba),
        /** permuted 5D tensor */
        cdeba(dnnl_cdeba),
        /** permuted 5D tensor */
        decab(dnnl_decab),

        // Opaque blocked formats

        Abc16a(dnnl_Abc16a),
        ABc16a16b(dnnl_ABc16a16b),
        aBc16b(dnnl_aBc16b),
        ABc16b16a(dnnl_ABc16b16a),
        Abc4a(dnnl_Abc4a),
        aBc4b(dnnl_aBc4b),
        ABc4b16a4b(dnnl_ABc4b16a4b),
        ABc4b4a(dnnl_ABc4b4a),
        ABc8a16b2a(dnnl_ABc8a16b2a),
        ABc8a8b(dnnl_ABc8a8b),
        aBc8b(dnnl_aBc8b),
        ABc8b16a2b(dnnl_ABc8b16a2b),
        ABc8b8a(dnnl_ABc8b8a),
        Abcd16a(dnnl_Abcd16a),
        ABcd16a16b(dnnl_ABcd16a16b),
        aBcd16b(dnnl_aBcd16b),
        ABcd16b16a(dnnl_ABcd16b16a),
        aBCd16b16c(dnnl_aBCd16b16c),
        aBCd16c16b(dnnl_aBCd16c16b),
        Abcd4a(dnnl_Abcd4a),
        aBcd4b(dnnl_aBcd4b),
        ABcd4b16a4b(dnnl_ABcd4b16a4b),
        ABcd4b4a(dnnl_ABcd4b4a),
        aBCd4c16b4c(dnnl_aBCd4c16b4c),
        aBCd4c4b(dnnl_aBCd4c4b),
        ABcd8a16b2a(dnnl_ABcd8a16b2a),
        ABcd8a8b(dnnl_ABcd8a8b),
        /** 4D tensor blocked by 2nd dimension with block size 8 */
        aBcd8b(dnnl_aBcd8b),
        ABcd8b16a2b(dnnl_ABcd8b16a2b),
        aBCd8b16c2b(dnnl_aBCd8b16c2b),
        /** 4D tensor blocked by 1st and 2nd dimension with block size 8 */
        ABcd8b8a(dnnl_ABcd8b8a),
        aBCd8b8c(dnnl_aBCd8b8c),
        aBCd8c16b2c(dnnl_aBCd8c16b2c),
        aBCd8c8b(dnnl_aBCd8c8b),
        Abcde16a(dnnl_Abcde16a),
        ABcde16a16b(dnnl_ABcde16a16b),
        aBcde16b(dnnl_aBcde16b),
        ABcde16b16a(dnnl_ABcde16b16a),
        aBCde16b16c(dnnl_aBCde16b16c),
        aBCde16c16b(dnnl_aBCde16c16b),
        aBCde2c8b4c(dnnl_aBCde2c8b4c),
        Abcde4a(dnnl_Abcde4a),
        aBcde4b(dnnl_aBcde4b),
        ABcde4b4a(dnnl_ABcde4b4a),
        aBCde4b4c(dnnl_aBCde4b4c),
        aBCde4c16b4c(dnnl_aBCde4c16b4c),
        aBCde4c4b(dnnl_aBCde4c4b),
        Abcde8a(dnnl_Abcde8a),
        ABcde8a8b(dnnl_ABcde8a8b),
        aBcde8b(dnnl_aBcde8b),
        ABcde8b16a2b(dnnl_ABcde8b16a2b),
        aBCde8b16c2b(dnnl_aBCde8b16c2b),
        ABcde8b8a(dnnl_ABcde8b8a),
        aBCde8b8c(dnnl_aBCde8b8c),
        ABcd4a8b8a4b(dnnl_ABcd4a8b8a4b),
        ABcd2a8b8a2b(dnnl_ABcd2a8b8a2b),
        aBCde4b8c8b4c(dnnl_aBCde4b8c8b4c),
        aBCde2b8c8b2c(dnnl_aBCde2b8c8b2c),
        aBCde8c16b2c(dnnl_aBCde8c16b2c),
        aBCde8c8b(dnnl_aBCde8c8b),
        aBcdef16b(dnnl_aBcdef16b),
        aBCdef16b16c(dnnl_aBCdef16b16c),
        aBCdef16c16b(dnnl_aBCdef16c16b),
        aBcdef4b(dnnl_aBcdef4b),
        aBCdef4c4b(dnnl_aBCdef4c4b),
        aBCdef8b8c(dnnl_aBCdef8b8c),
        aBCdef8c16b2c(dnnl_aBCdef8c16b2c),
        aBCdef8c8b(dnnl_aBCdef8c8b),
        aBdc16b(dnnl_aBdc16b),
        aBdc4b(dnnl_aBdc4b),
        aBdc8b(dnnl_aBdc8b),
        aBdec16b(dnnl_aBdec16b),
        aBdec4b(dnnl_aBdec4b),
        aBdec8b(dnnl_aBdec8b),
        aBdefc16b(dnnl_aBdefc16b),
        aCBdef16c16b(dnnl_aCBdef16c16b),
        aBdefc4b(dnnl_aBdefc4b),
        aBdefc8b(dnnl_aBdefc8b),
        Acb16a(dnnl_Acb16a),
        Acb4a(dnnl_Acb4a),
        Acb8a(dnnl_Acb8a),
        aCBd16b16c(dnnl_aCBd16b16c),
        aCBd16c16b(dnnl_aCBd16c16b),
        aCBde16b16c(dnnl_aCBde16b16c),
        aCBde16c16b(dnnl_aCBde16c16b),
        Acdb16a(dnnl_Acdb16a),
        Acdb4a(dnnl_Acdb4a),
        Acdb8a(dnnl_Acdb8a),
        Acdeb16a(dnnl_Acdeb16a),
        Acdeb4a(dnnl_Acdeb4a),
        Acdeb8a(dnnl_Acdeb8a),
        BAc16a16b(dnnl_BAc16a16b),
        BAc16b16a(dnnl_BAc16b16a),
        BAcd16a16b(dnnl_BAcd16a16b),
        BAcd16b16a(dnnl_BAcd16b16a),
        ABcd32a32b(dnnl_ABcd32a32b),
        BAcde16b16(dnnl_BAcde16b16a),
        aBdec32b(dnnl_aBdec32b),
        Abcdef16a(dnnl_Abcdef16a),
        Acdb32a(dnnl_Acdb32a),
        format_tag_last(dnnl_format_tag_last),

        x(dnnl_x),
        /** 2D CNN activations tensor,
         *  an alias to #dnnl::memory::format_tag::ab */
        nc(dnnl_nc),
        cn(dnnl_cn),
        tn(dnnl_tn),
        nt(dnnl_nt),
        ncw(dnnl_ncw),
        nwc(dnnl_nwc),
        /** 4D CNN activations tensor,
         *  an alias to #dnnl::memory::format_tag::abcd */
        nchw(dnnl_nchw),
        /** 4D CNN activations tensor,
         *  an alias to #dnnl::memory::format_tag::acdb */
        nhwc(dnnl_nhwc),
        /** 4D CNN activations tensor,
         *  an alias to #dnnl::memory::format_tag::bcda */
        chwn(dnnl_chwn),
        ncdhw(dnnl_ncdhw),
        ndhwc(dnnl_ndhwc),
        oi(dnnl_oi),
        io(dnnl_io),
        oiw(dnnl_oiw),
        wio(dnnl_wio),
        oihw(dnnl_oihw),
        hwio(dnnl_hwio),
        ihwo(dnnl_ihwo),
        iohw(dnnl_iohw),
        oidhw(dnnl_oidhw),
        dhwio(dnnl_dhwio),
        goiw(dnnl_goiw),
        goihw(dnnl_goihw),
        hwigo(dnnl_hwigo),
        giohw(dnnl_giohw),
        goidhw(dnnl_goidhw),
        tnc(dnnl_tnc),
        ntc(dnnl_ntc),
        ldnc(dnnl_ldnc),
        ldigo(dnnl_ldigo),
        ldgoi(dnnl_ldgoi),
        ldgo(dnnl_ldgo),
        nCdhw16c(dnnl_nCdhw16c),
        nCdhw4c(dnnl_nCdhw4c),
        nCdhw8c(dnnl_nCdhw8c),
        nChw16c(dnnl_nChw16c),
        nChw4c(dnnl_nChw4c),
        nChw8c(dnnl_nChw8c),
        nCw16c(dnnl_nCw16c),
        nCw4c(dnnl_nCw4c),
        nCw8c(dnnl_nCw8c),
        NCw16n16c(dnnl_NCw16n16c),
        NChw16n16c(dnnl_NChw16n16c),
        NCdhw16n16c(dnnl_NCdhw16n16c),
        NChw32n32c(dnnl_NChw32n32c),
        IOhw16i16o(dnnl_IOhw16i16o),
        Ohwi32o(dnnl_Ohwi32o),
        IOdhw16i16o(dnnl_IOdhw16i16o),
        gIOhw16i16o(dnnl_gIOhw16i16o),
        gOhwi32o(dnnl_gOhwi32o),
        Goidhw16g(dnnl_Goidhw16g),
        IOw16o16i(dnnl_IOw16o16i),
        OIw16i16o(dnnl_OIw16i16o),
        IOw16i16o(dnnl_IOw16i16o),
        gIOw16i16o(dnnl_gIOw16i16o),
        OIw16o16i(dnnl_OIw16o16i),
        Oiw16o(dnnl_Oiw16o),
        OIw4i16o4i(dnnl_OIw4i16o4i),
        OIw4i4o(dnnl_OIw4i4o),
        Oiw4o(dnnl_Oiw4o),
        OIw8i16o2i(dnnl_OIw8i16o2i),
        OIw8i8o(dnnl_OIw8i8o),
        OIw8o16i2o(dnnl_OIw8o16i2o),
        OIw8o8i(dnnl_OIw8o8i),
        Owi16o(dnnl_Owi16o),
        Owi4o(dnnl_Owi4o),
        Owi8o(dnnl_Owi8o),
        IOhw16o16i(dnnl_IOhw16o16i),
        Ohwi16o(dnnl_Ohwi16o),
        Ohwi4o(dnnl_Ohwi4o),
        Ohwi8o(dnnl_Ohwi8o),
        OIhw16i16o(dnnl_OIhw16i16o),
        OIhw16o16i(dnnl_OIhw16o16i),
        Oihw16o(dnnl_Oihw16o),
        OIhw4i16o4i(dnnl_OIhw4i16o4i),
        OIhw4i4o(dnnl_OIhw4i4o),
        Oihw4o(dnnl_Oihw4o),
        OIhw8i16o2i(dnnl_OIhw8i16o2i),
        OIhw8i8o(dnnl_OIhw8i8o),
        OIhw8o16i2o(dnnl_OIhw8o16i2o),
        OIhw8o8i(dnnl_OIhw8o8i),
        Odhwi16o(dnnl_Odhwi16o),
        Odhwi4o(dnnl_Odhwi4o),
        Odhwi8o(dnnl_Odhwi8o),
        OIdhw16i16o(dnnl_OIdhw16i16o),
        OIdhw16o16i(dnnl_OIdhw16o16i),
        Oidhw16o(dnnl_Oidhw16o),
        OIdhw4i4o(dnnl_OIdhw4i4o),
        Oidhw4o(dnnl_Oidhw4o),
        OIdhw8i16o2i(dnnl_OIdhw8i16o2i),
        OIdhw8i8o(dnnl_OIdhw8i8o),
        OIdhw8o8i(dnnl_OIdhw8o8i),
        gIOw16o16i(dnnl_gIOw16o16i),
        gOIw16i16o(dnnl_gOIw16i16o),
        gOIw16o16i(dnnl_gOIw16o16i),
        gOiw16o(dnnl_gOiw16o),
        gOIw4i16o4i(dnnl_gOIw4i16o4i),
        gOIw4i4o(dnnl_gOIw4i4o),
        gOiw4o(dnnl_gOiw4o),
        gOIw8i16o2i(dnnl_gOIw8i16o2i),
        gOIw8i8o(dnnl_gOIw8i8o),
        gOIw8o16i2o(dnnl_gOIw8o16i2o),
        gOIw8o8i(dnnl_gOIw8o8i),
        gOwi16o(dnnl_gOwi16o),
        gOwi4o(dnnl_gOwi4o),
        gOwi8o(dnnl_gOwi8o),
        gIOhw16o16i(dnnl_gIOhw16o16i),
        gOhwi16o(dnnl_gOhwi16o),
        gOhwi4o(dnnl_gOhwi4o),
        gOhwi8o(dnnl_gOhwi8o),
        Goihw16g(dnnl_Goihw16g),
        gOIhw16i16o(dnnl_gOIhw16i16o),
        gOIhw16o16i(dnnl_gOIhw16o16i),
        gOihw16o(dnnl_gOihw16o),
        gOIhw2i8o4i(dnnl_gOIhw2i8o4i),
        gOIhw4i16o4i(dnnl_gOIhw4i16o4i),
        gOIhw4i4o(dnnl_gOIhw4i4o),
        gOIhw4o4i(dnnl_gOIhw4o4i),
        gOihw4o(dnnl_gOihw4o),
        Goihw8g(dnnl_Goihw8g),
        gOIhw8i16o2i(dnnl_gOIhw8i16o2i),
        gOIhw8i8o(dnnl_gOIhw8i8o),
        gOIhw8o16i2o(dnnl_gOIhw8o16i2o),
        OIhw4o8i8o4i(dnnl_OIhw4o8i8o4i),
        OIhw2o8i8o2i(dnnl_OIhw2o8i8o2i),
        gOIhw4o8i8o4i(dnnl_gOIhw4o8i8o4i),
        gOIhw2o8i8o2i(dnnl_gOIhw2o8i8o2i),
        gOIhw8o8i(dnnl_gOIhw8o8i),
        gIOdhw16i16o(dnnl_gIOdhw16i16o),
        gOdhwi16o(dnnl_gOdhwi16o),
        gOdhwi4o(dnnl_gOdhwi4o),
        gOdhwi8o(dnnl_gOdhwi8o),
        gOIdhw16i16o(dnnl_gOIdhw16i16o),
        gOIdhw16o16i(dnnl_gOIdhw16o16i),
        gOidhw16o(dnnl_gOidhw16o),
        gOIdhw4i4o(dnnl_gOIdhw4i4o),
        gOidhw4o(dnnl_gOidhw4o),
        gOIdhw8i16o2i(dnnl_gOIdhw8i16o2i),
        gOIdhw8i8o(dnnl_gOIdhw8i8o),
        gOIdhw8o8i(dnnl_gOIdhw8o8i);

        public final int value;
        private format_tag(int v) { this.value = v; }
        private format_tag(format_tag e) { this.value = e.value; }
        public format_tag intern() { for (format_tag e : values()) if (e.value == value) return e; return this; }
        @Override public String toString() { return intern().name(); }
    }

    /** A memory descriptor. */
    @NoOffset public static class desc extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public desc(Pointer p) { super(p); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public desc(long size) { super((Pointer)null); allocateArray(size); }
        private native void allocateArray(long size);
        @Override public desc position(long position) {
            return (desc)super.position(position);
        }
    
        /** The underlying C API data structure. */
        public native @ByRef dnnl_memory_desc_t data(); public native desc data(dnnl_memory_desc_t setter);

        /** Constructs a zero memory descriptor */
        
        ///
        public desc() { super((Pointer)null); allocate(); }
        private native void allocate();

        /** Constructs a memory descriptor.
         * 
         *  @param adims Data dimensions
         *  @param adata_type Data precision/type.
         *  @param aformat_tag Data layout format tag. */
        
        ///
        public desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer adims, @ByVal data_type adata_type, @ByVal format_tag aformat_tag) { super((Pointer)null); allocate(adims, adata_type, aformat_tag); }
        private native void allocate(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer adims, @ByVal data_type adata_type, @ByVal format_tag aformat_tag);
        public desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer adims, @ByVal data_type adata_type, @ByVal format_tag aformat_tag) { super((Pointer)null); allocate(adims, adata_type, aformat_tag); }
        private native void allocate(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer adims, @ByVal data_type adata_type, @ByVal format_tag aformat_tag);
        public desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] adims, @ByVal data_type adata_type, @ByVal format_tag aformat_tag) { super((Pointer)null); allocate(adims, adata_type, aformat_tag); }
        private native void allocate(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] adims, @ByVal data_type adata_type, @ByVal format_tag aformat_tag);

        /** Constructs a memory descriptor by strides.
         * 
         *  @param adims Data dimensions
         *  @param adata_type Data precision/type.
         *  @param astrides The strides for dimensions. */
        
        ///
        public desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer adims, @ByVal data_type adata_type, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer astrides) { super((Pointer)null); allocate(adims, adata_type, astrides); }
        private native void allocate(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer adims, @ByVal data_type adata_type, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer astrides);
        public desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer adims, @ByVal data_type adata_type, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer astrides) { super((Pointer)null); allocate(adims, adata_type, astrides); }
        private native void allocate(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer adims, @ByVal data_type adata_type, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer astrides);
        public desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] adims, @ByVal data_type adata_type, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] astrides) { super((Pointer)null); allocate(adims, adata_type, astrides); }
        private native void allocate(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] adims, @ByVal data_type adata_type, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] astrides);

        /** Constructs a memory descriptor from a C API data structure.
         * 
         *  @param adata A C API #dnnl_memory_desc_t structure. */
        public desc(@Const @ByRef dnnl_memory_desc_t adata) { super((Pointer)null); allocate(adata); }
        private native void allocate(@Const @ByRef dnnl_memory_desc_t adata);

        /** Constructs a sub-memory descriptor. */
        //
        /** @param adims Sizes of a sub-memory
        /** @param offsets Offsets of a sub-memory */
        public native @ByVal desc submemory_desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer adims, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer offsets);
        public native @ByVal desc submemory_desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer adims, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer offsets);
        public native @ByVal desc submemory_desc(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] adims, @Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] offsets);

        /** Constructs a memory descriptor by reshaping existing one. */
        public native @ByVal desc reshape(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongPointer adims);
        public native @ByVal desc reshape(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef LongBuffer adims);
        public native @ByVal desc reshape(@Const @Cast({"dnnl_dim_t*", "std::vector<dnnl_dim_t>&"}) @StdVector("dnnl_dim_t") @ByRef long[] adims);

        /** Returns the number of bytes required to allocate the memory
         *  described including the padding area. */
        public native @Cast("size_t") long get_size();

        /** Returns true if the memory descriptor describes an empty memory */
        public native @Cast("bool") boolean is_zero();

        public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef desc other);

        public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef desc other);
    }

    
    ///
    public memory() { super((Pointer)null); allocate(); }
    private native void allocate();

    /** Constructs a memory.
     * 
     *  @param md Memory descriptor.
     *  @param aengine Engine.
     *  @param ahandle handle. */
    
    ///
    public memory(@Const @ByRef desc md, @Const @ByRef engine aengine, Pointer ahandle) { super((Pointer)null); allocate(md, aengine, ahandle); }
    private native void allocate(@Const @ByRef desc md, @Const @ByRef engine aengine, Pointer ahandle);

    /** Constructs a memory.
     * 
     *  @param md Memory descriptor.
     *  @param aengine Engine. */
    public memory(@Const @ByRef desc md, @Const @ByRef engine aengine) { super((Pointer)null); allocate(md, aengine); }
    private native void allocate(@Const @ByRef desc md, @Const @ByRef engine aengine);

    /** Returns the descriptor of the memory. */
    public native @ByVal desc get_desc();

    /** Returns the engine of the memory. */
    
    ///
    public native @ByVal engine get_engine();

    /** Returns a handle of the data contained in the memory.
     * 
     *  On the CPU engine, this is a pointer to the allocated memory. */
    public native Pointer get_data_handle();

    
    ///
    ///
    ///
    ///
    public native void set_data_handle(Pointer handle);

    /** Maps the data of the memory.
     * 
     *  Mapping allows to read/write directly from/to the memory contents for
     *  engines that do not support direct memory access.
     * 
     *  Mapping is an exclusive operation - a memory object cannot be used in
     *  other operations until this memory object is unmapped.
     *  \tparam T Type of the pointer to be mapped.
     * 
     *  \note Any primitives working with the memory should be completed before
     *        mapping. Use stream::wait() to synchronize the corresponding
     *        execution stream.
     * 
     *  \note Map/unmap API is provided mainly for debug/testing purposes and
     *        its performance may be suboptimal. */

    /** Unmaps the previously mapped data for the memory.
     * 
     *  Any changes of the mapped data are synchronized back to the memory
     *  after the call is complete. The mapped pointer must be
     *  obtained through a map_data() call.
     * 
     *  \note Map/unmap API is provided mainly for debug/testing purposes and
     *        its performance may be suboptimal. */
    public native void unmap_data(Pointer mapped_ptr);

// #if DNNL_GPU_RUNTIME == DNNL_RUNTIME_OCL
// #endif

    // Must go away or be private:
    public static native @Cast("dnnl_data_type_t") int convert_to_c(@ByVal data_type adata_type);
    public static native @Cast("dnnl_format_tag_t") int convert_to_c(@ByVal format_tag aformat);
}
