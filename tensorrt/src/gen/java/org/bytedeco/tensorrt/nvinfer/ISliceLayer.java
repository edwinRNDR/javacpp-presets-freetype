// Targeted by JavaCPP version 1.5.2: DO NOT EDIT THIS FILE

package org.bytedeco.tensorrt.nvinfer;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import org.bytedeco.cuda.cudart.*;
import static org.bytedeco.cuda.global.cudart.*;

import static org.bytedeco.tensorrt.global.nvinfer.*;


/**
 *  \brief Slices an input tensor into an output tensor based on the offset and strides.
 * 
 *  The slice layer has two variants, static and dynamic. Static slice specifies the start, size, and stride
 *  dimensions at layer create time via Dims and can use the get/set accessor functions of the ISliceLayer. Dynamic
 *  slice specifies the start and size dimensions at layer create time via ITensors and uses ILayer::setTensor to
 *  set the optional stride parameter after layer construction.
 *  An application can determine if the ISliceLayer is dynamic or static based on if there are 3 or 4 inputs(Dynamic)
 *  or 1 input(Static). When working on a shape tensor, a dynamic slace layer must have start, size, and stride
 *  specified at build time.
 * 
 *  The slice layer selects for each dimension a start location from within the input tensor, and given the
 *  specified stride, copies strided elements to the output tensor. Start, Size, and Stride shape tensors must be
 *  DataType::kINT32.
 * 
 *  For example using slice on a data tensor:
 *  input = {{0, 1}, {2, 3}, {4, 5}}
 *  start = {1, 0}
 *  size = {1, 2}
 *  stride = {1, 2}
 *  output = {1, 5}
 * 
 *  \warning Do not inherit from this class, as doing so will break forward-compatibility of the API and ABI.
 *  */
@Namespace("nvinfer1") @Properties(inherit = org.bytedeco.tensorrt.presets.nvinfer.class)
public class ISliceLayer extends ILayer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ISliceLayer(Pointer p) { super(p); }

    /**
     *  \brief Set the start offset that the slice layer uses to create the output slice.
     * 
     *  @param start The start offset to read data from the input tensor.
     * 
     *  If the SliceLayer is using dynamic inputs for the start parameter, calling setStart() results in an error
     *  and does not update the dimensions.
     * 
     *  @see getStart
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    public native void setStart(@ByVal Dims start);

    /**
     *  \brief Get the start offset for the slice layer.
     * 
     *  @return The start offset, or an invalid Dims structure.
     * 
     *  If the SliceLayer is using dynamic inputs for the start parameter, this function returns an invalid
     *  Dims structure.
     * 
     *  @see setStart
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    public native @ByVal Dims getStart();

    /**
     *  \brief Set the dimensions of the output slice.
     * 
     *  @param size The dimensions of the output slice.
     * 
     *  If the SliceLayer is using dynamic inputs for the size parameter, calling setSize() results in an error
     *  and does not update the dimensions.
     * 
     *  @see getSize
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    public native void setSize(@ByVal Dims size);

    /**
     *  \brief Get dimensions of the output slice.
     * 
     *  @return The output dimension, or an invalid Dims structure.
     * 
     *  If the SliceLayer is using dynamic inputs for the size parameter, this function returns an invalid
     *  Dims structure.
     * 
     *  @see setSize
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    public native @ByVal Dims getSize();

    /**
     *  \brief Set the stride for computing the output slice data.
     * 
     *  @param stride The dimensions of the stride to compute the values to store in the output slice.
     * 
     *  If the SliceLayer is using dynamic inputs for the stride parameter, calling setSlice() results in an error
     *  and does not update the dimensions.
     * 
     *  @see getStride
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    public native void setStride(@ByVal Dims stride);

    /**
     *  \brief Get the stride for the output slice.
     * 
     *  @return The slicing stride, or an invalid Dims structure.
     * 
     *  If the SliceLayer is using dynamic inputs for the stride parameter, this function returns a invalid
     *  Dims structure.
     * 
     *  @see setStride
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    public native @ByVal Dims getStride();

    /**
     *  \brief replace an input of this layer with a specific tensor.
     * 
     *  @param index the index of the input to modify.
     *  @param tensor the new input tensor
     * 
     *  Sets the input tensor for the given index. The index must be 0 for a static slice layer.
     *  A static slice layer is converted to a dynamic slice layer by calling setInput with an index > 0.
     *  A dynamic slice layer cannot be converted back to a static slice layer.
     * 
     *  For a dynamic slice layer, the values 0-3 are valid. If an index > 0 is specified, all values between
     *  index 0 and that index must be dynamic tensors. The values larger than index can use static dimensions.
     *  For example, if an index of two is specified, the stride tensor can be set via setStride, but the start tensor
     *  must be specified via setInput as both size and start are converted to dynamic tensors.
     *  The indices in the dynamic case are as follows:
     * 
     *  Index | Description
     *    0   | Data or Shape tensor to be sliced.
     *    1   | The start tensor to begin slicing, N-dimensional for Data, and 1-D for Shape.
     *    2   | The size tensor of the resulting slice, N-dimensional for Data, and 1-D for Shape.
     *    3   | The stride of the slicing operation, N-dimensional for Data, and 1-D for Shape.
     * 
     *  If this function is called with a value greater than 0, then the function getNbInputs() changes
     *  from returning 1 to index + 1. When converting from static to dynamic slice layer,
     *  all unset tensors, between 1 and index + 1, are initialized to nullptr. It is an error to attempt to build
     *  a network that has any nullptr inputs.
     *  */
    public native void setInput(int index, @ByRef ITensor tensor);
}
