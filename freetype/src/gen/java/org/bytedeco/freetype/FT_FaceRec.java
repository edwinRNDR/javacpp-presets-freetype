// Targeted by JavaCPP version 1.5.2-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.freetype;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.freetype.global.freetype.*;



  /**************************************************************************
   *
   * \struct:
   *   FT_FaceRec
   *
   * \description:
   *   FreeType root face class structure.  A face object models a typeface
   *   in a font file.
   *
   * \fields:
   *   num_faces ::
   *     The number of faces in the font file.  Some font formats can have
   *     multiple faces in a single font file.
   *
   *   face_index ::
   *     This field holds two different values.  Bits 0-15 are the index of
   *     the face in the font file (starting with value~0).  They are set
   *     to~0 if there is only one face in the font file.
   *
   *     [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation
   *     fonts only, holding the named instance index for the current face
   *     index (starting with value~1; value~0 indicates font access without
   *     a named instance).  For non-variation fonts, bits 16-30 are ignored.
   *     If we have the third named instance of face~4, say, {@code face_index} is
   *     set to 0x00030004.
   *
   *     Bit 31 is always zero (this is, {@code face_index} is always a positive
   *     value).
   *
   *     [Since 2.9] Changing the design coordinates with
   *     \FT_Set_Var_Design_Coordinates or \FT_Set_Var_Blend_Coordinates does
   *     not influence the named instance index value (only
   *     \FT_Set_Named_Instance does that).
   *
   *   face_flags ::
   *     A set of bit flags that give important information about the face;
   *     see \FT_FACE_FLAG_XXX for the details.
   *
   *   style_flags ::
   *     The lower 16~bits contain a set of bit flags indicating the style of
   *     the face; see \FT_STYLE_FLAG_XXX for the details.
   *
   *     [Since 2.6.1] Bits 16-30 hold the number of named instances
   *     available for the current face if we have a GX or OpenType variation
   *     (sub)font.  Bit 31 is always zero (this is, {@code style_flags} is always
   *     a positive value).  Note that a variation font has always at least
   *     one named instance, namely the default instance.
   *
   *   num_glyphs ::
   *     The number of glyphs in the face.  If the face is scalable and has
   *     sbits (see {@code num_fixed_sizes}), it is set to the number of outline
   *     glyphs.
   *
   *     For CID-keyed fonts (not in an SFNT wrapper) this value gives the
   *     highest CID used in the font.
   *
   *   family_name ::
   *     The face's family name.  This is an ASCII string, usually in
   *     English, that describes the typeface's family (like 'Times New
   *     Roman', 'Bodoni', 'Garamond', etc).  This is a least common
   *     denominator used to list fonts.  Some formats (TrueType & OpenType)
   *     provide localized and Unicode versions of this string.  Applications
   *     should use the format-specific interface to access them.  Can be
   *     {@code NULL} (e.g., in fonts embedded in a PDF file).
   *
   *     In case the font doesn't provide a specific family name entry,
   *     FreeType tries to synthesize one, deriving it from other name
   *     entries.
   *
   *   style_name ::
   *     The face's style name.  This is an ASCII string, usually in English,
   *     that describes the typeface's style (like 'Italic', 'Bold',
   *     'Condensed', etc).  Not all font formats provide a style name, so
   *     this field is optional, and can be set to {@code NULL}.  As for
   *     {@code family_name}, some formats provide localized and Unicode versions
   *     of this string.  Applications should use the format-specific
   *     interface to access them.
   *
   *   num_fixed_sizes ::
   *     The number of bitmap strikes in the face.  Even if the face is
   *     scalable, there might still be bitmap strikes, which are called
   *     'sbits' in that case.
   *
   *   available_sizes ::
   *     An array of \FT_Bitmap_Size for all bitmap strikes in the face.  It
   *     is set to {@code NULL} if there is no bitmap strike.
   *
   *     Note that FreeType tries to sanitize the strike data since they are
   *     sometimes sloppy or incorrect, but this can easily fail.
   *
   *   num_charmaps ::
   *     The number of charmaps in the face.
   *
   *   charmaps ::
   *     An array of the charmaps of the face.
   *
   *   generic ::
   *     A field reserved for client uses.  See the \FT_Generic type
   *     description.
   *
   *   bbox ::
   *     The font bounding box.  Coordinates are expressed in font units (see
   *     {@code units_per_EM}).  The box is large enough to contain any glyph from
   *     the font.  Thus, {@code bbox.yMax} can be seen as the 'maximum ascender',
   *     and {@code bbox.yMin} as the 'minimum descender'.  Only relevant for
   *     scalable formats.
   *
   *     Note that the bounding box might be off by (at least) one pixel for
   *     hinted fonts.  See \FT_Size_Metrics for further discussion.
   *
   *   units_per_EM ::
   *     The number of font units per EM square for this face.  This is
   *     typically 2048 for TrueType fonts, and 1000 for Type~1 fonts.  Only
   *     relevant for scalable formats.
   *
   *   ascender ::
   *     The typographic ascender of the face, expressed in font units.  For
   *     font formats not having this information, it is set to {@code bbox.yMax}.
   *     Only relevant for scalable formats.
   *
   *   descender ::
   *     The typographic descender of the face, expressed in font units.  For
   *     font formats not having this information, it is set to {@code bbox.yMin}.
   *     Note that this field is negative for values below the baseline.
   *     Only relevant for scalable formats.
   *
   *   height ::
   *     This value is the vertical distance between two consecutive
   *     baselines, expressed in font units.  It is always positive.  Only
   *     relevant for scalable formats.
   *
   *     If you want the global glyph height, use {@code ascender - descender}.
   *
   *   max_advance_width ::
   *     The maximum advance width, in font units, for all glyphs in this
   *     face.  This can be used to make word wrapping computations faster.
   *     Only relevant for scalable formats.
   *
   *   max_advance_height ::
   *     The maximum advance height, in font units, for all glyphs in this
   *     face.  This is only relevant for vertical layouts, and is set to
   *     {@code height} for fonts that do not provide vertical metrics.  Only
   *     relevant for scalable formats.
   *
   *   underline_position ::
   *     The position, in font units, of the underline line for this face.
   *     It is the center of the underlining stem.  Only relevant for
   *     scalable formats.
   *
   *   underline_thickness ::
   *     The thickness, in font units, of the underline for this face.  Only
   *     relevant for scalable formats.
   *
   *   glyph ::
   *     The face's associated glyph slot(s).
   *
   *   size ::
   *     The current active size for this face.
   *
   *   charmap ::
   *     The current active charmap for this face.
   *
   * \note:
   *   Fields may be changed after a call to \FT_Attach_File or
   *   \FT_Attach_Stream.
   *
   *   For an OpenType variation font, the values of the following fields can
   *   change after a call to \FT_Set_Var_Design_Coordinates (and friends) if
   *   the font contains an 'MVAR' table: {@code ascender}, {@code descender}, {@code height},
   *   {@code underline_position}, and {@code underline_thickness}.
   *
   *   Especially for TrueType fonts see also the documentation for
   *   \FT_Size_Metrics.
   */
  @Properties(inherit = org.bytedeco.freetype.presets.freetype.class)
public class FT_FaceRec extends Pointer {
      static { Loader.load(); }
      /** Default native constructor. */
      public FT_FaceRec() { super((Pointer)null); allocate(); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public FT_FaceRec(long size) { super((Pointer)null); allocateArray(size); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public FT_FaceRec(Pointer p) { super(p); }
      private native void allocate();
      private native void allocateArray(long size);
      @Override public FT_FaceRec position(long position) {
          return (FT_FaceRec)super.position(position);
      }
  
    public native @Cast("FT_Long") long num_faces(); public native FT_FaceRec num_faces(long setter);
    public native @Cast("FT_Long") long face_index(); public native FT_FaceRec face_index(long setter);

    public native @Cast("FT_Long") long face_flags(); public native FT_FaceRec face_flags(long setter);
    public native @Cast("FT_Long") long style_flags(); public native FT_FaceRec style_flags(long setter);

    public native @Cast("FT_Long") long num_glyphs(); public native FT_FaceRec num_glyphs(long setter);

    public native @Cast("FT_String*") BytePointer family_name(); public native FT_FaceRec family_name(BytePointer setter);
    public native @Cast("FT_String*") BytePointer style_name(); public native FT_FaceRec style_name(BytePointer setter);

    public native @Cast("FT_Int") int num_fixed_sizes(); public native FT_FaceRec num_fixed_sizes(int setter);
    public native FT_Bitmap_Size available_sizes(); public native FT_FaceRec available_sizes(FT_Bitmap_Size setter);

    public native @Cast("FT_Int") int num_charmaps(); public native FT_FaceRec num_charmaps(int setter);
    public native @Cast("FT_CharMap*") PointerPointer charmaps(); public native FT_FaceRec charmaps(PointerPointer setter);

    public native @ByRef FT_Generic generic(); public native FT_FaceRec generic(FT_Generic setter);

    /*# The following member variables (down to `underline_thickness`) */
    /*# are only relevant to scalable outlines; cf. @FT_Bitmap_Size    */
    /*# for bitmap fonts.                                              */
    public native @ByRef FT_BBox bbox(); public native FT_FaceRec bbox(FT_BBox setter);

    public native @Cast("FT_UShort") short units_per_EM(); public native FT_FaceRec units_per_EM(short setter);
    public native @Cast("FT_Short") short ascender(); public native FT_FaceRec ascender(short setter);
    public native @Cast("FT_Short") short descender(); public native FT_FaceRec descender(short setter);
    public native @Cast("FT_Short") short height(); public native FT_FaceRec height(short setter);

    public native @Cast("FT_Short") short max_advance_width(); public native FT_FaceRec max_advance_width(short setter);
    public native @Cast("FT_Short") short max_advance_height(); public native FT_FaceRec max_advance_height(short setter);

    public native @Cast("FT_Short") short underline_position(); public native FT_FaceRec underline_position(short setter);
    public native @Cast("FT_Short") short underline_thickness(); public native FT_FaceRec underline_thickness(short setter);

    public native FT_GlyphSlot glyph(); public native FT_FaceRec glyph(FT_GlyphSlot setter);
    public native FT_Size size(); public native FT_FaceRec size(FT_Size setter);
    public native FT_CharMap charmap(); public native FT_FaceRec charmap(FT_CharMap setter);

    /*@private begin */

    public native FT_Driver driver(); public native FT_FaceRec driver(FT_Driver setter);
    public native FT_Memory memory(); public native FT_FaceRec memory(FT_Memory setter);
    public native FT_Stream stream(); public native FT_FaceRec stream(FT_Stream setter);

    public native @ByRef FT_ListRec sizes_list(); public native FT_FaceRec sizes_list(FT_ListRec setter);

    public native @ByRef FT_Generic autohint(); public native FT_FaceRec autohint(FT_Generic setter);   /* face-specific auto-hinter data */
    public native Pointer extensions(); public native FT_FaceRec extensions(Pointer setter); /* unused                         */

    public native FT_Face_Internal internal(); public native FT_FaceRec internal(FT_Face_Internal setter);

    /*@private end */

  }
